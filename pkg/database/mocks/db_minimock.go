// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i platform-pkg/pkg/database.DB -o db_minimock.go -n DBMock -p mocks

import (
	"context"
	mm_database "platform-pkg/pkg/database"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// DBMock implements mm_database.DB
type DBMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBeginTx          func(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error)
	funcBeginTxOrigin    string
	inspectFuncBeginTx   func(ctx context.Context, txOptions pgx.TxOptions)
	afterBeginTxCounter  uint64
	beforeBeginTxCounter uint64
	BeginTxMock          mDBMockBeginTx

	funcClose          func()
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mDBMockClose

	funcExecContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)
	funcExecContextOrigin    string
	inspectFuncExecContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterExecContextCounter  uint64
	beforeExecContextCounter uint64
	ExecContextMock          mDBMockExecContext

	funcPing          func(ctx context.Context) (err error)
	funcPingOrigin    string
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mDBMockPing

	funcQueryContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error)
	funcQueryContextOrigin    string
	inspectFuncQueryContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterQueryContextCounter  uint64
	beforeQueryContextCounter uint64
	QueryContextMock          mDBMockQueryContext

	funcQueryRowContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row)
	funcQueryRowContextOrigin    string
	inspectFuncQueryRowContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterQueryRowContextCounter  uint64
	beforeQueryRowContextCounter uint64
	QueryRowContextMock          mDBMockQueryRowContext

	funcScanAllContext          func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error)
	funcScanAllContextOrigin    string
	inspectFuncScanAllContext   func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{})
	afterScanAllContextCounter  uint64
	beforeScanAllContextCounter uint64
	ScanAllContextMock          mDBMockScanAllContext

	funcScanOneContext          func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error)
	funcScanOneContextOrigin    string
	inspectFuncScanOneContext   func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{})
	afterScanOneContextCounter  uint64
	beforeScanOneContextCounter uint64
	ScanOneContextMock          mDBMockScanOneContext
}

// NewDBMock returns a mock for mm_database.DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginTxMock = mDBMockBeginTx{mock: m}
	m.BeginTxMock.callArgs = []*DBMockBeginTxParams{}

	m.CloseMock = mDBMockClose{mock: m}

	m.ExecContextMock = mDBMockExecContext{mock: m}
	m.ExecContextMock.callArgs = []*DBMockExecContextParams{}

	m.PingMock = mDBMockPing{mock: m}
	m.PingMock.callArgs = []*DBMockPingParams{}

	m.QueryContextMock = mDBMockQueryContext{mock: m}
	m.QueryContextMock.callArgs = []*DBMockQueryContextParams{}

	m.QueryRowContextMock = mDBMockQueryRowContext{mock: m}
	m.QueryRowContextMock.callArgs = []*DBMockQueryRowContextParams{}

	m.ScanAllContextMock = mDBMockScanAllContext{mock: m}
	m.ScanAllContextMock.callArgs = []*DBMockScanAllContextParams{}

	m.ScanOneContextMock = mDBMockScanOneContext{mock: m}
	m.ScanOneContextMock.callArgs = []*DBMockScanOneContextParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDBMockBeginTx struct {
	optional           bool
	mock               *DBMock
	defaultExpectation *DBMockBeginTxExpectation
	expectations       []*DBMockBeginTxExpectation

	callArgs []*DBMockBeginTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DBMockBeginTxExpectation specifies expectation struct of the DB.BeginTx
type DBMockBeginTxExpectation struct {
	mock               *DBMock
	params             *DBMockBeginTxParams
	paramPtrs          *DBMockBeginTxParamPtrs
	expectationOrigins DBMockBeginTxExpectationOrigins
	results            *DBMockBeginTxResults
	returnOrigin       string
	Counter            uint64
}

// DBMockBeginTxParams contains parameters of the DB.BeginTx
type DBMockBeginTxParams struct {
	ctx       context.Context
	txOptions pgx.TxOptions
}

// DBMockBeginTxParamPtrs contains pointers to parameters of the DB.BeginTx
type DBMockBeginTxParamPtrs struct {
	ctx       *context.Context
	txOptions *pgx.TxOptions
}

// DBMockBeginTxResults contains results of the DB.BeginTx
type DBMockBeginTxResults struct {
	t1  pgx.Tx
	err error
}

// DBMockBeginTxOrigins contains origins of expectations of the DB.BeginTx
type DBMockBeginTxExpectationOrigins struct {
	origin          string
	originCtx       string
	originTxOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBeginTx *mDBMockBeginTx) Optional() *mDBMockBeginTx {
	mmBeginTx.optional = true
	return mmBeginTx
}

// Expect sets up expected params for DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Expect(ctx context.Context, txOptions pgx.TxOptions) *mDBMockBeginTx {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &DBMockBeginTxExpectation{}
	}

	if mmBeginTx.defaultExpectation.paramPtrs != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by ExpectParams functions")
	}

	mmBeginTx.defaultExpectation.params = &DBMockBeginTxParams{ctx, txOptions}
	mmBeginTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBeginTx.expectations {
		if minimock.Equal(e.params, mmBeginTx.defaultExpectation.params) {
			mmBeginTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginTx.defaultExpectation.params)
		}
	}

	return mmBeginTx
}

// ExpectCtxParam1 sets up expected param ctx for DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) ExpectCtxParam1(ctx context.Context) *mDBMockBeginTx {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &DBMockBeginTxExpectation{}
	}

	if mmBeginTx.defaultExpectation.params != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Expect")
	}

	if mmBeginTx.defaultExpectation.paramPtrs == nil {
		mmBeginTx.defaultExpectation.paramPtrs = &DBMockBeginTxParamPtrs{}
	}
	mmBeginTx.defaultExpectation.paramPtrs.ctx = &ctx
	mmBeginTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBeginTx
}

// ExpectTxOptionsParam2 sets up expected param txOptions for DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) ExpectTxOptionsParam2(txOptions pgx.TxOptions) *mDBMockBeginTx {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &DBMockBeginTxExpectation{}
	}

	if mmBeginTx.defaultExpectation.params != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Expect")
	}

	if mmBeginTx.defaultExpectation.paramPtrs == nil {
		mmBeginTx.defaultExpectation.paramPtrs = &DBMockBeginTxParamPtrs{}
	}
	mmBeginTx.defaultExpectation.paramPtrs.txOptions = &txOptions
	mmBeginTx.defaultExpectation.expectationOrigins.originTxOptions = minimock.CallerInfo(1)

	return mmBeginTx
}

// Inspect accepts an inspector function that has same arguments as the DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Inspect(f func(ctx context.Context, txOptions pgx.TxOptions)) *mDBMockBeginTx {
	if mmBeginTx.mock.inspectFuncBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("Inspect function is already set for DBMock.BeginTx")
	}

	mmBeginTx.mock.inspectFuncBeginTx = f

	return mmBeginTx
}

// Return sets up results that will be returned by DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Return(t1 pgx.Tx, err error) *DBMock {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &DBMockBeginTxExpectation{mock: mmBeginTx.mock}
	}
	mmBeginTx.defaultExpectation.results = &DBMockBeginTxResults{t1, err}
	mmBeginTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBeginTx.mock
}

// Set uses given function f to mock the DB.BeginTx method
func (mmBeginTx *mDBMockBeginTx) Set(f func(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error)) *DBMock {
	if mmBeginTx.defaultExpectation != nil {
		mmBeginTx.mock.t.Fatalf("Default expectation is already set for the DB.BeginTx method")
	}

	if len(mmBeginTx.expectations) > 0 {
		mmBeginTx.mock.t.Fatalf("Some expectations are already set for the DB.BeginTx method")
	}

	mmBeginTx.mock.funcBeginTx = f
	mmBeginTx.mock.funcBeginTxOrigin = minimock.CallerInfo(1)
	return mmBeginTx.mock
}

// When sets expectation for the DB.BeginTx which will trigger the result defined by the following
// Then helper
func (mmBeginTx *mDBMockBeginTx) When(ctx context.Context, txOptions pgx.TxOptions) *DBMockBeginTxExpectation {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	expectation := &DBMockBeginTxExpectation{
		mock:               mmBeginTx.mock,
		params:             &DBMockBeginTxParams{ctx, txOptions},
		expectationOrigins: DBMockBeginTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBeginTx.expectations = append(mmBeginTx.expectations, expectation)
	return expectation
}

// Then sets up DB.BeginTx return parameters for the expectation previously defined by the When method
func (e *DBMockBeginTxExpectation) Then(t1 pgx.Tx, err error) *DBMock {
	e.results = &DBMockBeginTxResults{t1, err}
	return e.mock
}

// Times sets number of times DB.BeginTx should be invoked
func (mmBeginTx *mDBMockBeginTx) Times(n uint64) *mDBMockBeginTx {
	if n == 0 {
		mmBeginTx.mock.t.Fatalf("Times of DBMock.BeginTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBeginTx.expectedInvocations, n)
	mmBeginTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBeginTx
}

func (mmBeginTx *mDBMockBeginTx) invocationsDone() bool {
	if len(mmBeginTx.expectations) == 0 && mmBeginTx.defaultExpectation == nil && mmBeginTx.mock.funcBeginTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBeginTx.mock.afterBeginTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBeginTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BeginTx implements mm_database.DB
func (mmBeginTx *DBMock) BeginTx(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBeginTx.beforeBeginTxCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginTx.afterBeginTxCounter, 1)

	mmBeginTx.t.Helper()

	if mmBeginTx.inspectFuncBeginTx != nil {
		mmBeginTx.inspectFuncBeginTx(ctx, txOptions)
	}

	mm_params := DBMockBeginTxParams{ctx, txOptions}

	// Record call args
	mmBeginTx.BeginTxMock.mutex.Lock()
	mmBeginTx.BeginTxMock.callArgs = append(mmBeginTx.BeginTxMock.callArgs, &mm_params)
	mmBeginTx.BeginTxMock.mutex.Unlock()

	for _, e := range mmBeginTx.BeginTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBeginTx.BeginTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginTx.BeginTxMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginTx.BeginTxMock.defaultExpectation.params
		mm_want_ptrs := mmBeginTx.BeginTxMock.defaultExpectation.paramPtrs

		mm_got := DBMockBeginTxParams{ctx, txOptions}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBeginTx.t.Errorf("DBMock.BeginTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBeginTx.BeginTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.txOptions != nil && !minimock.Equal(*mm_want_ptrs.txOptions, mm_got.txOptions) {
				mmBeginTx.t.Errorf("DBMock.BeginTx got unexpected parameter txOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBeginTx.BeginTxMock.defaultExpectation.expectationOrigins.originTxOptions, *mm_want_ptrs.txOptions, mm_got.txOptions, minimock.Diff(*mm_want_ptrs.txOptions, mm_got.txOptions))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginTx.t.Errorf("DBMock.BeginTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBeginTx.BeginTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginTx.BeginTxMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginTx.t.Fatal("No results are set for the DBMock.BeginTx")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBeginTx.funcBeginTx != nil {
		return mmBeginTx.funcBeginTx(ctx, txOptions)
	}
	mmBeginTx.t.Fatalf("Unexpected call to DBMock.BeginTx. %v %v", ctx, txOptions)
	return
}

// BeginTxAfterCounter returns a count of finished DBMock.BeginTx invocations
func (mmBeginTx *DBMock) BeginTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.afterBeginTxCounter)
}

// BeginTxBeforeCounter returns a count of DBMock.BeginTx invocations
func (mmBeginTx *DBMock) BeginTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.beforeBeginTxCounter)
}

// Calls returns a list of arguments used in each call to DBMock.BeginTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginTx *mDBMockBeginTx) Calls() []*DBMockBeginTxParams {
	mmBeginTx.mutex.RLock()

	argCopy := make([]*DBMockBeginTxParams, len(mmBeginTx.callArgs))
	copy(argCopy, mmBeginTx.callArgs)

	mmBeginTx.mutex.RUnlock()

	return argCopy
}

// MinimockBeginTxDone returns true if the count of the BeginTx invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockBeginTxDone() bool {
	if m.BeginTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginTxMock.invocationsDone()
}

// MinimockBeginTxInspect logs each unmet expectation
func (m *DBMock) MinimockBeginTxInspect() {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.BeginTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBeginTxCounter := mm_atomic.LoadUint64(&m.afterBeginTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && afterBeginTxCounter < 1 {
		if m.BeginTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DBMock.BeginTx at\n%s", m.BeginTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DBMock.BeginTx at\n%s with params: %#v", m.BeginTxMock.defaultExpectation.expectationOrigins.origin, *m.BeginTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && afterBeginTxCounter < 1 {
		m.t.Errorf("Expected call to DBMock.BeginTx at\n%s", m.funcBeginTxOrigin)
	}

	if !m.BeginTxMock.invocationsDone() && afterBeginTxCounter > 0 {
		m.t.Errorf("Expected %d calls to DBMock.BeginTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginTxMock.expectedInvocations), m.BeginTxMock.expectedInvocationsOrigin, afterBeginTxCounter)
	}
}

type mDBMockClose struct {
	optional           bool
	mock               *DBMock
	defaultExpectation *DBMockCloseExpectation
	expectations       []*DBMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DBMockCloseExpectation specifies expectation struct of the DB.Close
type DBMockCloseExpectation struct {
	mock *DBMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mDBMockClose) Optional() *mDBMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for DB.Close
func (mmClose *mDBMockClose) Expect() *mDBMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("DBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &DBMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the DB.Close
func (mmClose *mDBMockClose) Inspect(f func()) *mDBMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for DBMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by DB.Close
func (mmClose *mDBMockClose) Return() *DBMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("DBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &DBMockCloseExpectation{mock: mmClose.mock}
	}

	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the DB.Close method
func (mmClose *mDBMockClose) Set(f func()) *DBMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the DB.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the DB.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times DB.Close should be invoked
func (mmClose *mDBMockClose) Times(n uint64) *mDBMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of DBMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mDBMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_database.DB
func (mmClose *DBMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to DBMock.Close.")

}

// CloseAfterCounter returns a count of finished DBMock.Close invocations
func (mmClose *DBMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of DBMock.Close invocations
func (mmClose *DBMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *DBMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DBMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to DBMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to DBMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to DBMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mDBMockExecContext struct {
	optional           bool
	mock               *DBMock
	defaultExpectation *DBMockExecContextExpectation
	expectations       []*DBMockExecContextExpectation

	callArgs []*DBMockExecContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DBMockExecContextExpectation specifies expectation struct of the DB.ExecContext
type DBMockExecContextExpectation struct {
	mock               *DBMock
	params             *DBMockExecContextParams
	paramPtrs          *DBMockExecContextParamPtrs
	expectationOrigins DBMockExecContextExpectationOrigins
	results            *DBMockExecContextResults
	returnOrigin       string
	Counter            uint64
}

// DBMockExecContextParams contains parameters of the DB.ExecContext
type DBMockExecContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// DBMockExecContextParamPtrs contains pointers to parameters of the DB.ExecContext
type DBMockExecContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// DBMockExecContextResults contains results of the DB.ExecContext
type DBMockExecContextResults struct {
	c2  pgconn.CommandTag
	err error
}

// DBMockExecContextOrigins contains origins of expectations of the DB.ExecContext
type DBMockExecContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExecContext *mDBMockExecContext) Optional() *mDBMockExecContext {
	mmExecContext.optional = true
	return mmExecContext
}

// Expect sets up expected params for DB.ExecContext
func (mmExecContext *mDBMockExecContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mDBMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &DBMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.paramPtrs != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by ExpectParams functions")
	}

	mmExecContext.defaultExpectation.params = &DBMockExecContextParams{ctx, q, args}
	mmExecContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExecContext.expectations {
		if minimock.Equal(e.params, mmExecContext.defaultExpectation.params) {
			mmExecContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecContext.defaultExpectation.params)
		}
	}

	return mmExecContext
}

// ExpectCtxParam1 sets up expected param ctx for DB.ExecContext
func (mmExecContext *mDBMockExecContext) ExpectCtxParam1(ctx context.Context) *mDBMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &DBMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &DBMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmExecContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExecContext
}

// ExpectQParam2 sets up expected param q for DB.ExecContext
func (mmExecContext *mDBMockExecContext) ExpectQParam2(q mm_database.Query) *mDBMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &DBMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &DBMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.q = &q
	mmExecContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmExecContext
}

// ExpectArgsParam3 sets up expected param args for DB.ExecContext
func (mmExecContext *mDBMockExecContext) ExpectArgsParam3(args ...interface{}) *mDBMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &DBMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &DBMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.args = &args
	mmExecContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmExecContext
}

// Inspect accepts an inspector function that has same arguments as the DB.ExecContext
func (mmExecContext *mDBMockExecContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mDBMockExecContext {
	if mmExecContext.mock.inspectFuncExecContext != nil {
		mmExecContext.mock.t.Fatalf("Inspect function is already set for DBMock.ExecContext")
	}

	mmExecContext.mock.inspectFuncExecContext = f

	return mmExecContext
}

// Return sets up results that will be returned by DB.ExecContext
func (mmExecContext *mDBMockExecContext) Return(c2 pgconn.CommandTag, err error) *DBMock {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &DBMockExecContextExpectation{mock: mmExecContext.mock}
	}
	mmExecContext.defaultExpectation.results = &DBMockExecContextResults{c2, err}
	mmExecContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExecContext.mock
}

// Set uses given function f to mock the DB.ExecContext method
func (mmExecContext *mDBMockExecContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)) *DBMock {
	if mmExecContext.defaultExpectation != nil {
		mmExecContext.mock.t.Fatalf("Default expectation is already set for the DB.ExecContext method")
	}

	if len(mmExecContext.expectations) > 0 {
		mmExecContext.mock.t.Fatalf("Some expectations are already set for the DB.ExecContext method")
	}

	mmExecContext.mock.funcExecContext = f
	mmExecContext.mock.funcExecContextOrigin = minimock.CallerInfo(1)
	return mmExecContext.mock
}

// When sets expectation for the DB.ExecContext which will trigger the result defined by the following
// Then helper
func (mmExecContext *mDBMockExecContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *DBMockExecContextExpectation {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	expectation := &DBMockExecContextExpectation{
		mock:               mmExecContext.mock,
		params:             &DBMockExecContextParams{ctx, q, args},
		expectationOrigins: DBMockExecContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExecContext.expectations = append(mmExecContext.expectations, expectation)
	return expectation
}

// Then sets up DB.ExecContext return parameters for the expectation previously defined by the When method
func (e *DBMockExecContextExpectation) Then(c2 pgconn.CommandTag, err error) *DBMock {
	e.results = &DBMockExecContextResults{c2, err}
	return e.mock
}

// Times sets number of times DB.ExecContext should be invoked
func (mmExecContext *mDBMockExecContext) Times(n uint64) *mDBMockExecContext {
	if n == 0 {
		mmExecContext.mock.t.Fatalf("Times of DBMock.ExecContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExecContext.expectedInvocations, n)
	mmExecContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExecContext
}

func (mmExecContext *mDBMockExecContext) invocationsDone() bool {
	if len(mmExecContext.expectations) == 0 && mmExecContext.defaultExpectation == nil && mmExecContext.mock.funcExecContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExecContext.mock.afterExecContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExecContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExecContext implements mm_database.DB
func (mmExecContext *DBMock) ExecContext(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExecContext.beforeExecContextCounter, 1)
	defer mm_atomic.AddUint64(&mmExecContext.afterExecContextCounter, 1)

	mmExecContext.t.Helper()

	if mmExecContext.inspectFuncExecContext != nil {
		mmExecContext.inspectFuncExecContext(ctx, q, args...)
	}

	mm_params := DBMockExecContextParams{ctx, q, args}

	// Record call args
	mmExecContext.ExecContextMock.mutex.Lock()
	mmExecContext.ExecContextMock.callArgs = append(mmExecContext.ExecContextMock.callArgs, &mm_params)
	mmExecContext.ExecContextMock.mutex.Unlock()

	for _, e := range mmExecContext.ExecContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmExecContext.ExecContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecContext.ExecContextMock.defaultExpectation.Counter, 1)
		mm_want := mmExecContext.ExecContextMock.defaultExpectation.params
		mm_want_ptrs := mmExecContext.ExecContextMock.defaultExpectation.paramPtrs

		mm_got := DBMockExecContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExecContext.t.Errorf("DBMock.ExecContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmExecContext.t.Errorf("DBMock.ExecContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmExecContext.t.Errorf("DBMock.ExecContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecContext.t.Errorf("DBMock.ExecContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecContext.ExecContextMock.defaultExpectation.results
		if mm_results == nil {
			mmExecContext.t.Fatal("No results are set for the DBMock.ExecContext")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmExecContext.funcExecContext != nil {
		return mmExecContext.funcExecContext(ctx, q, args...)
	}
	mmExecContext.t.Fatalf("Unexpected call to DBMock.ExecContext. %v %v %v", ctx, q, args)
	return
}

// ExecContextAfterCounter returns a count of finished DBMock.ExecContext invocations
func (mmExecContext *DBMock) ExecContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.afterExecContextCounter)
}

// ExecContextBeforeCounter returns a count of DBMock.ExecContext invocations
func (mmExecContext *DBMock) ExecContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.beforeExecContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.ExecContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecContext *mDBMockExecContext) Calls() []*DBMockExecContextParams {
	mmExecContext.mutex.RLock()

	argCopy := make([]*DBMockExecContextParams, len(mmExecContext.callArgs))
	copy(argCopy, mmExecContext.callArgs)

	mmExecContext.mutex.RUnlock()

	return argCopy
}

// MinimockExecContextDone returns true if the count of the ExecContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockExecContextDone() bool {
	if m.ExecContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecContextMock.invocationsDone()
}

// MinimockExecContextInspect logs each unmet expectation
func (m *DBMock) MinimockExecContextInspect() {
	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.ExecContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecContextCounter := mm_atomic.LoadUint64(&m.afterExecContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecContextMock.defaultExpectation != nil && afterExecContextCounter < 1 {
		if m.ExecContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DBMock.ExecContext at\n%s", m.ExecContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DBMock.ExecContext at\n%s with params: %#v", m.ExecContextMock.defaultExpectation.expectationOrigins.origin, *m.ExecContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecContext != nil && afterExecContextCounter < 1 {
		m.t.Errorf("Expected call to DBMock.ExecContext at\n%s", m.funcExecContextOrigin)
	}

	if !m.ExecContextMock.invocationsDone() && afterExecContextCounter > 0 {
		m.t.Errorf("Expected %d calls to DBMock.ExecContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecContextMock.expectedInvocations), m.ExecContextMock.expectedInvocationsOrigin, afterExecContextCounter)
	}
}

type mDBMockPing struct {
	optional           bool
	mock               *DBMock
	defaultExpectation *DBMockPingExpectation
	expectations       []*DBMockPingExpectation

	callArgs []*DBMockPingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DBMockPingExpectation specifies expectation struct of the DB.Ping
type DBMockPingExpectation struct {
	mock               *DBMock
	params             *DBMockPingParams
	paramPtrs          *DBMockPingParamPtrs
	expectationOrigins DBMockPingExpectationOrigins
	results            *DBMockPingResults
	returnOrigin       string
	Counter            uint64
}

// DBMockPingParams contains parameters of the DB.Ping
type DBMockPingParams struct {
	ctx context.Context
}

// DBMockPingParamPtrs contains pointers to parameters of the DB.Ping
type DBMockPingParamPtrs struct {
	ctx *context.Context
}

// DBMockPingResults contains results of the DB.Ping
type DBMockPingResults struct {
	err error
}

// DBMockPingOrigins contains origins of expectations of the DB.Ping
type DBMockPingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPing *mDBMockPing) Optional() *mDBMockPing {
	mmPing.optional = true
	return mmPing
}

// Expect sets up expected params for DB.Ping
func (mmPing *mDBMockPing) Expect(ctx context.Context) *mDBMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &DBMockPingExpectation{}
	}

	if mmPing.defaultExpectation.paramPtrs != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by ExpectParams functions")
	}

	mmPing.defaultExpectation.params = &DBMockPingParams{ctx}
	mmPing.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// ExpectCtxParam1 sets up expected param ctx for DB.Ping
func (mmPing *mDBMockPing) ExpectCtxParam1(ctx context.Context) *mDBMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &DBMockPingExpectation{}
	}

	if mmPing.defaultExpectation.params != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Expect")
	}

	if mmPing.defaultExpectation.paramPtrs == nil {
		mmPing.defaultExpectation.paramPtrs = &DBMockPingParamPtrs{}
	}
	mmPing.defaultExpectation.paramPtrs.ctx = &ctx
	mmPing.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the DB.Ping
func (mmPing *mDBMockPing) Inspect(f func(ctx context.Context)) *mDBMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for DBMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by DB.Ping
func (mmPing *mDBMockPing) Return(err error) *DBMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &DBMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &DBMockPingResults{err}
	mmPing.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPing.mock
}

// Set uses given function f to mock the DB.Ping method
func (mmPing *mDBMockPing) Set(f func(ctx context.Context) (err error)) *DBMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the DB.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the DB.Ping method")
	}

	mmPing.mock.funcPing = f
	mmPing.mock.funcPingOrigin = minimock.CallerInfo(1)
	return mmPing.mock
}

// When sets expectation for the DB.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mDBMockPing) When(ctx context.Context) *DBMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	expectation := &DBMockPingExpectation{
		mock:               mmPing.mock,
		params:             &DBMockPingParams{ctx},
		expectationOrigins: DBMockPingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up DB.Ping return parameters for the expectation previously defined by the When method
func (e *DBMockPingExpectation) Then(err error) *DBMock {
	e.results = &DBMockPingResults{err}
	return e.mock
}

// Times sets number of times DB.Ping should be invoked
func (mmPing *mDBMockPing) Times(n uint64) *mDBMockPing {
	if n == 0 {
		mmPing.mock.t.Fatalf("Times of DBMock.Ping mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPing.expectedInvocations, n)
	mmPing.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPing
}

func (mmPing *mDBMockPing) invocationsDone() bool {
	if len(mmPing.expectations) == 0 && mmPing.defaultExpectation == nil && mmPing.mock.funcPing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPing.mock.afterPingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ping implements mm_database.DB
func (mmPing *DBMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	mmPing.t.Helper()

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := DBMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_want_ptrs := mmPing.PingMock.defaultExpectation.paramPtrs

		mm_got := DBMockPingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPing.t.Errorf("DBMock.Ping got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPing.PingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("DBMock.Ping got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPing.PingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the DBMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to DBMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished DBMock.Ping invocations
func (mmPing *DBMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of DBMock.Ping invocations
func (mmPing *DBMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to DBMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mDBMockPing) Calls() []*DBMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*DBMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockPingDone() bool {
	if m.PingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PingMock.invocationsDone()
}

// MinimockPingInspect logs each unmet expectation
func (m *DBMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.Ping at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPingCounter := mm_atomic.LoadUint64(&m.afterPingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && afterPingCounter < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DBMock.Ping at\n%s", m.PingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DBMock.Ping at\n%s with params: %#v", m.PingMock.defaultExpectation.expectationOrigins.origin, *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && afterPingCounter < 1 {
		m.t.Errorf("Expected call to DBMock.Ping at\n%s", m.funcPingOrigin)
	}

	if !m.PingMock.invocationsDone() && afterPingCounter > 0 {
		m.t.Errorf("Expected %d calls to DBMock.Ping at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PingMock.expectedInvocations), m.PingMock.expectedInvocationsOrigin, afterPingCounter)
	}
}

type mDBMockQueryContext struct {
	optional           bool
	mock               *DBMock
	defaultExpectation *DBMockQueryContextExpectation
	expectations       []*DBMockQueryContextExpectation

	callArgs []*DBMockQueryContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DBMockQueryContextExpectation specifies expectation struct of the DB.QueryContext
type DBMockQueryContextExpectation struct {
	mock               *DBMock
	params             *DBMockQueryContextParams
	paramPtrs          *DBMockQueryContextParamPtrs
	expectationOrigins DBMockQueryContextExpectationOrigins
	results            *DBMockQueryContextResults
	returnOrigin       string
	Counter            uint64
}

// DBMockQueryContextParams contains parameters of the DB.QueryContext
type DBMockQueryContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// DBMockQueryContextParamPtrs contains pointers to parameters of the DB.QueryContext
type DBMockQueryContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// DBMockQueryContextResults contains results of the DB.QueryContext
type DBMockQueryContextResults struct {
	r1  pgx.Rows
	err error
}

// DBMockQueryContextOrigins contains origins of expectations of the DB.QueryContext
type DBMockQueryContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryContext *mDBMockQueryContext) Optional() *mDBMockQueryContext {
	mmQueryContext.optional = true
	return mmQueryContext
}

// Expect sets up expected params for DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mDBMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &DBMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.paramPtrs != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by ExpectParams functions")
	}

	mmQueryContext.defaultExpectation.params = &DBMockQueryContextParams{ctx, q, args}
	mmQueryContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryContext.expectations {
		if minimock.Equal(e.params, mmQueryContext.defaultExpectation.params) {
			mmQueryContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryContext.defaultExpectation.params)
		}
	}

	return mmQueryContext
}

// ExpectCtxParam1 sets up expected param ctx for DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) ExpectCtxParam1(ctx context.Context) *mDBMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &DBMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &DBMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryContext
}

// ExpectQParam2 sets up expected param q for DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) ExpectQParam2(q mm_database.Query) *mDBMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &DBMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &DBMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.q = &q
	mmQueryContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmQueryContext
}

// ExpectArgsParam3 sets up expected param args for DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) ExpectArgsParam3(args ...interface{}) *mDBMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &DBMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &DBMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.args = &args
	mmQueryContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryContext
}

// Inspect accepts an inspector function that has same arguments as the DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mDBMockQueryContext {
	if mmQueryContext.mock.inspectFuncQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("Inspect function is already set for DBMock.QueryContext")
	}

	mmQueryContext.mock.inspectFuncQueryContext = f

	return mmQueryContext
}

// Return sets up results that will be returned by DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) Return(r1 pgx.Rows, err error) *DBMock {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &DBMockQueryContextExpectation{mock: mmQueryContext.mock}
	}
	mmQueryContext.defaultExpectation.results = &DBMockQueryContextResults{r1, err}
	mmQueryContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryContext.mock
}

// Set uses given function f to mock the DB.QueryContext method
func (mmQueryContext *mDBMockQueryContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error)) *DBMock {
	if mmQueryContext.defaultExpectation != nil {
		mmQueryContext.mock.t.Fatalf("Default expectation is already set for the DB.QueryContext method")
	}

	if len(mmQueryContext.expectations) > 0 {
		mmQueryContext.mock.t.Fatalf("Some expectations are already set for the DB.QueryContext method")
	}

	mmQueryContext.mock.funcQueryContext = f
	mmQueryContext.mock.funcQueryContextOrigin = minimock.CallerInfo(1)
	return mmQueryContext.mock
}

// When sets expectation for the DB.QueryContext which will trigger the result defined by the following
// Then helper
func (mmQueryContext *mDBMockQueryContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *DBMockQueryContextExpectation {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	expectation := &DBMockQueryContextExpectation{
		mock:               mmQueryContext.mock,
		params:             &DBMockQueryContextParams{ctx, q, args},
		expectationOrigins: DBMockQueryContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryContext.expectations = append(mmQueryContext.expectations, expectation)
	return expectation
}

// Then sets up DB.QueryContext return parameters for the expectation previously defined by the When method
func (e *DBMockQueryContextExpectation) Then(r1 pgx.Rows, err error) *DBMock {
	e.results = &DBMockQueryContextResults{r1, err}
	return e.mock
}

// Times sets number of times DB.QueryContext should be invoked
func (mmQueryContext *mDBMockQueryContext) Times(n uint64) *mDBMockQueryContext {
	if n == 0 {
		mmQueryContext.mock.t.Fatalf("Times of DBMock.QueryContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryContext.expectedInvocations, n)
	mmQueryContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryContext
}

func (mmQueryContext *mDBMockQueryContext) invocationsDone() bool {
	if len(mmQueryContext.expectations) == 0 && mmQueryContext.defaultExpectation == nil && mmQueryContext.mock.funcQueryContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryContext.mock.afterQueryContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryContext implements mm_database.DB
func (mmQueryContext *DBMock) QueryContext(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQueryContext.beforeQueryContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryContext.afterQueryContextCounter, 1)

	mmQueryContext.t.Helper()

	if mmQueryContext.inspectFuncQueryContext != nil {
		mmQueryContext.inspectFuncQueryContext(ctx, q, args...)
	}

	mm_params := DBMockQueryContextParams{ctx, q, args}

	// Record call args
	mmQueryContext.QueryContextMock.mutex.Lock()
	mmQueryContext.QueryContextMock.callArgs = append(mmQueryContext.QueryContextMock.callArgs, &mm_params)
	mmQueryContext.QueryContextMock.mutex.Unlock()

	for _, e := range mmQueryContext.QueryContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQueryContext.QueryContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryContext.QueryContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryContext.QueryContextMock.defaultExpectation.params
		mm_want_ptrs := mmQueryContext.QueryContextMock.defaultExpectation.paramPtrs

		mm_got := DBMockQueryContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryContext.t.Errorf("DBMock.QueryContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmQueryContext.t.Errorf("DBMock.QueryContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryContext.t.Errorf("DBMock.QueryContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryContext.t.Errorf("DBMock.QueryContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryContext.QueryContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryContext.t.Fatal("No results are set for the DBMock.QueryContext")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQueryContext.funcQueryContext != nil {
		return mmQueryContext.funcQueryContext(ctx, q, args...)
	}
	mmQueryContext.t.Fatalf("Unexpected call to DBMock.QueryContext. %v %v %v", ctx, q, args)
	return
}

// QueryContextAfterCounter returns a count of finished DBMock.QueryContext invocations
func (mmQueryContext *DBMock) QueryContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.afterQueryContextCounter)
}

// QueryContextBeforeCounter returns a count of DBMock.QueryContext invocations
func (mmQueryContext *DBMock) QueryContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.beforeQueryContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.QueryContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryContext *mDBMockQueryContext) Calls() []*DBMockQueryContextParams {
	mmQueryContext.mutex.RLock()

	argCopy := make([]*DBMockQueryContextParams, len(mmQueryContext.callArgs))
	copy(argCopy, mmQueryContext.callArgs)

	mmQueryContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryContextDone returns true if the count of the QueryContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockQueryContextDone() bool {
	if m.QueryContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryContextMock.invocationsDone()
}

// MinimockQueryContextInspect logs each unmet expectation
func (m *DBMock) MinimockQueryContextInspect() {
	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.QueryContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryContextCounter := mm_atomic.LoadUint64(&m.afterQueryContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryContextMock.defaultExpectation != nil && afterQueryContextCounter < 1 {
		if m.QueryContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DBMock.QueryContext at\n%s", m.QueryContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DBMock.QueryContext at\n%s with params: %#v", m.QueryContextMock.defaultExpectation.expectationOrigins.origin, *m.QueryContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryContext != nil && afterQueryContextCounter < 1 {
		m.t.Errorf("Expected call to DBMock.QueryContext at\n%s", m.funcQueryContextOrigin)
	}

	if !m.QueryContextMock.invocationsDone() && afterQueryContextCounter > 0 {
		m.t.Errorf("Expected %d calls to DBMock.QueryContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryContextMock.expectedInvocations), m.QueryContextMock.expectedInvocationsOrigin, afterQueryContextCounter)
	}
}

type mDBMockQueryRowContext struct {
	optional           bool
	mock               *DBMock
	defaultExpectation *DBMockQueryRowContextExpectation
	expectations       []*DBMockQueryRowContextExpectation

	callArgs []*DBMockQueryRowContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DBMockQueryRowContextExpectation specifies expectation struct of the DB.QueryRowContext
type DBMockQueryRowContextExpectation struct {
	mock               *DBMock
	params             *DBMockQueryRowContextParams
	paramPtrs          *DBMockQueryRowContextParamPtrs
	expectationOrigins DBMockQueryRowContextExpectationOrigins
	results            *DBMockQueryRowContextResults
	returnOrigin       string
	Counter            uint64
}

// DBMockQueryRowContextParams contains parameters of the DB.QueryRowContext
type DBMockQueryRowContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// DBMockQueryRowContextParamPtrs contains pointers to parameters of the DB.QueryRowContext
type DBMockQueryRowContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// DBMockQueryRowContextResults contains results of the DB.QueryRowContext
type DBMockQueryRowContextResults struct {
	r1 pgx.Row
}

// DBMockQueryRowContextOrigins contains origins of expectations of the DB.QueryRowContext
type DBMockQueryRowContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryRowContext *mDBMockQueryRowContext) Optional() *mDBMockQueryRowContext {
	mmQueryRowContext.optional = true
	return mmQueryRowContext
}

// Expect sets up expected params for DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mDBMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &DBMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by ExpectParams functions")
	}

	mmQueryRowContext.defaultExpectation.params = &DBMockQueryRowContextParams{ctx, q, args}
	mmQueryRowContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryRowContext.expectations {
		if minimock.Equal(e.params, mmQueryRowContext.defaultExpectation.params) {
			mmQueryRowContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRowContext.defaultExpectation.params)
		}
	}

	return mmQueryRowContext
}

// ExpectCtxParam1 sets up expected param ctx for DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) ExpectCtxParam1(ctx context.Context) *mDBMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &DBMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &DBMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryRowContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// ExpectQParam2 sets up expected param q for DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) ExpectQParam2(q mm_database.Query) *mDBMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &DBMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &DBMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.q = &q
	mmQueryRowContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// ExpectArgsParam3 sets up expected param args for DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) ExpectArgsParam3(args ...interface{}) *mDBMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &DBMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &DBMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.args = &args
	mmQueryRowContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// Inspect accepts an inspector function that has same arguments as the DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mDBMockQueryRowContext {
	if mmQueryRowContext.mock.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("Inspect function is already set for DBMock.QueryRowContext")
	}

	mmQueryRowContext.mock.inspectFuncQueryRowContext = f

	return mmQueryRowContext
}

// Return sets up results that will be returned by DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) Return(r1 pgx.Row) *DBMock {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &DBMockQueryRowContextExpectation{mock: mmQueryRowContext.mock}
	}
	mmQueryRowContext.defaultExpectation.results = &DBMockQueryRowContextResults{r1}
	mmQueryRowContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext.mock
}

// Set uses given function f to mock the DB.QueryRowContext method
func (mmQueryRowContext *mDBMockQueryRowContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row)) *DBMock {
	if mmQueryRowContext.defaultExpectation != nil {
		mmQueryRowContext.mock.t.Fatalf("Default expectation is already set for the DB.QueryRowContext method")
	}

	if len(mmQueryRowContext.expectations) > 0 {
		mmQueryRowContext.mock.t.Fatalf("Some expectations are already set for the DB.QueryRowContext method")
	}

	mmQueryRowContext.mock.funcQueryRowContext = f
	mmQueryRowContext.mock.funcQueryRowContextOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext.mock
}

// When sets expectation for the DB.QueryRowContext which will trigger the result defined by the following
// Then helper
func (mmQueryRowContext *mDBMockQueryRowContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *DBMockQueryRowContextExpectation {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	expectation := &DBMockQueryRowContextExpectation{
		mock:               mmQueryRowContext.mock,
		params:             &DBMockQueryRowContextParams{ctx, q, args},
		expectationOrigins: DBMockQueryRowContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryRowContext.expectations = append(mmQueryRowContext.expectations, expectation)
	return expectation
}

// Then sets up DB.QueryRowContext return parameters for the expectation previously defined by the When method
func (e *DBMockQueryRowContextExpectation) Then(r1 pgx.Row) *DBMock {
	e.results = &DBMockQueryRowContextResults{r1}
	return e.mock
}

// Times sets number of times DB.QueryRowContext should be invoked
func (mmQueryRowContext *mDBMockQueryRowContext) Times(n uint64) *mDBMockQueryRowContext {
	if n == 0 {
		mmQueryRowContext.mock.t.Fatalf("Times of DBMock.QueryRowContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryRowContext.expectedInvocations, n)
	mmQueryRowContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext
}

func (mmQueryRowContext *mDBMockQueryRowContext) invocationsDone() bool {
	if len(mmQueryRowContext.expectations) == 0 && mmQueryRowContext.defaultExpectation == nil && mmQueryRowContext.mock.funcQueryRowContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryRowContext.mock.afterQueryRowContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryRowContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryRowContext implements mm_database.DB
func (mmQueryRowContext *DBMock) QueryRowContext(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRowContext.beforeQueryRowContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRowContext.afterQueryRowContextCounter, 1)

	mmQueryRowContext.t.Helper()

	if mmQueryRowContext.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.inspectFuncQueryRowContext(ctx, q, args...)
	}

	mm_params := DBMockQueryRowContextParams{ctx, q, args}

	// Record call args
	mmQueryRowContext.QueryRowContextMock.mutex.Lock()
	mmQueryRowContext.QueryRowContextMock.callArgs = append(mmQueryRowContext.QueryRowContextMock.callArgs, &mm_params)
	mmQueryRowContext.QueryRowContextMock.mutex.Unlock()

	for _, e := range mmQueryRowContext.QueryRowContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRowContext.QueryRowContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRowContext.QueryRowContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRowContext.QueryRowContextMock.defaultExpectation.params
		mm_want_ptrs := mmQueryRowContext.QueryRowContextMock.defaultExpectation.paramPtrs

		mm_got := DBMockQueryRowContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryRowContext.t.Errorf("DBMock.QueryRowContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmQueryRowContext.t.Errorf("DBMock.QueryRowContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryRowContext.t.Errorf("DBMock.QueryRowContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRowContext.t.Errorf("DBMock.QueryRowContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRowContext.QueryRowContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRowContext.t.Fatal("No results are set for the DBMock.QueryRowContext")
		}
		return (*mm_results).r1
	}
	if mmQueryRowContext.funcQueryRowContext != nil {
		return mmQueryRowContext.funcQueryRowContext(ctx, q, args...)
	}
	mmQueryRowContext.t.Fatalf("Unexpected call to DBMock.QueryRowContext. %v %v %v", ctx, q, args)
	return
}

// QueryRowContextAfterCounter returns a count of finished DBMock.QueryRowContext invocations
func (mmQueryRowContext *DBMock) QueryRowContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.afterQueryRowContextCounter)
}

// QueryRowContextBeforeCounter returns a count of DBMock.QueryRowContext invocations
func (mmQueryRowContext *DBMock) QueryRowContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.beforeQueryRowContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.QueryRowContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRowContext *mDBMockQueryRowContext) Calls() []*DBMockQueryRowContextParams {
	mmQueryRowContext.mutex.RLock()

	argCopy := make([]*DBMockQueryRowContextParams, len(mmQueryRowContext.callArgs))
	copy(argCopy, mmQueryRowContext.callArgs)

	mmQueryRowContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowContextDone returns true if the count of the QueryRowContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockQueryRowContextDone() bool {
	if m.QueryRowContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryRowContextMock.invocationsDone()
}

// MinimockQueryRowContextInspect logs each unmet expectation
func (m *DBMock) MinimockQueryRowContextInspect() {
	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.QueryRowContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryRowContextCounter := mm_atomic.LoadUint64(&m.afterQueryRowContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowContextMock.defaultExpectation != nil && afterQueryRowContextCounter < 1 {
		if m.QueryRowContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DBMock.QueryRowContext at\n%s", m.QueryRowContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DBMock.QueryRowContext at\n%s with params: %#v", m.QueryRowContextMock.defaultExpectation.expectationOrigins.origin, *m.QueryRowContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRowContext != nil && afterQueryRowContextCounter < 1 {
		m.t.Errorf("Expected call to DBMock.QueryRowContext at\n%s", m.funcQueryRowContextOrigin)
	}

	if !m.QueryRowContextMock.invocationsDone() && afterQueryRowContextCounter > 0 {
		m.t.Errorf("Expected %d calls to DBMock.QueryRowContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryRowContextMock.expectedInvocations), m.QueryRowContextMock.expectedInvocationsOrigin, afterQueryRowContextCounter)
	}
}

type mDBMockScanAllContext struct {
	optional           bool
	mock               *DBMock
	defaultExpectation *DBMockScanAllContextExpectation
	expectations       []*DBMockScanAllContextExpectation

	callArgs []*DBMockScanAllContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DBMockScanAllContextExpectation specifies expectation struct of the DB.ScanAllContext
type DBMockScanAllContextExpectation struct {
	mock               *DBMock
	params             *DBMockScanAllContextParams
	paramPtrs          *DBMockScanAllContextParamPtrs
	expectationOrigins DBMockScanAllContextExpectationOrigins
	results            *DBMockScanAllContextResults
	returnOrigin       string
	Counter            uint64
}

// DBMockScanAllContextParams contains parameters of the DB.ScanAllContext
type DBMockScanAllContextParams struct {
	ctx  context.Context
	deps interface{}
	q    mm_database.Query
	args []interface{}
}

// DBMockScanAllContextParamPtrs contains pointers to parameters of the DB.ScanAllContext
type DBMockScanAllContextParamPtrs struct {
	ctx  *context.Context
	deps *interface{}
	q    *mm_database.Query
	args *[]interface{}
}

// DBMockScanAllContextResults contains results of the DB.ScanAllContext
type DBMockScanAllContextResults struct {
	err error
}

// DBMockScanAllContextOrigins contains origins of expectations of the DB.ScanAllContext
type DBMockScanAllContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originDeps string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScanAllContext *mDBMockScanAllContext) Optional() *mDBMockScanAllContext {
	mmScanAllContext.optional = true
	return mmScanAllContext
}

// Expect sets up expected params for DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) Expect(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) *mDBMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &DBMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.paramPtrs != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by ExpectParams functions")
	}

	mmScanAllContext.defaultExpectation.params = &DBMockScanAllContextParams{ctx, deps, q, args}
	mmScanAllContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScanAllContext.expectations {
		if minimock.Equal(e.params, mmScanAllContext.defaultExpectation.params) {
			mmScanAllContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanAllContext.defaultExpectation.params)
		}
	}

	return mmScanAllContext
}

// ExpectCtxParam1 sets up expected param ctx for DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) ExpectCtxParam1(ctx context.Context) *mDBMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &DBMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.params != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Expect")
	}

	if mmScanAllContext.defaultExpectation.paramPtrs == nil {
		mmScanAllContext.defaultExpectation.paramPtrs = &DBMockScanAllContextParamPtrs{}
	}
	mmScanAllContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmScanAllContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmScanAllContext
}

// ExpectDepsParam2 sets up expected param deps for DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) ExpectDepsParam2(deps interface{}) *mDBMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &DBMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.params != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Expect")
	}

	if mmScanAllContext.defaultExpectation.paramPtrs == nil {
		mmScanAllContext.defaultExpectation.paramPtrs = &DBMockScanAllContextParamPtrs{}
	}
	mmScanAllContext.defaultExpectation.paramPtrs.deps = &deps
	mmScanAllContext.defaultExpectation.expectationOrigins.originDeps = minimock.CallerInfo(1)

	return mmScanAllContext
}

// ExpectQParam3 sets up expected param q for DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) ExpectQParam3(q mm_database.Query) *mDBMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &DBMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.params != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Expect")
	}

	if mmScanAllContext.defaultExpectation.paramPtrs == nil {
		mmScanAllContext.defaultExpectation.paramPtrs = &DBMockScanAllContextParamPtrs{}
	}
	mmScanAllContext.defaultExpectation.paramPtrs.q = &q
	mmScanAllContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmScanAllContext
}

// ExpectArgsParam4 sets up expected param args for DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) ExpectArgsParam4(args ...interface{}) *mDBMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &DBMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.params != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Expect")
	}

	if mmScanAllContext.defaultExpectation.paramPtrs == nil {
		mmScanAllContext.defaultExpectation.paramPtrs = &DBMockScanAllContextParamPtrs{}
	}
	mmScanAllContext.defaultExpectation.paramPtrs.args = &args
	mmScanAllContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmScanAllContext
}

// Inspect accepts an inspector function that has same arguments as the DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) Inspect(f func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{})) *mDBMockScanAllContext {
	if mmScanAllContext.mock.inspectFuncScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("Inspect function is already set for DBMock.ScanAllContext")
	}

	mmScanAllContext.mock.inspectFuncScanAllContext = f

	return mmScanAllContext
}

// Return sets up results that will be returned by DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) Return(err error) *DBMock {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &DBMockScanAllContextExpectation{mock: mmScanAllContext.mock}
	}
	mmScanAllContext.defaultExpectation.results = &DBMockScanAllContextResults{err}
	mmScanAllContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScanAllContext.mock
}

// Set uses given function f to mock the DB.ScanAllContext method
func (mmScanAllContext *mDBMockScanAllContext) Set(f func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error)) *DBMock {
	if mmScanAllContext.defaultExpectation != nil {
		mmScanAllContext.mock.t.Fatalf("Default expectation is already set for the DB.ScanAllContext method")
	}

	if len(mmScanAllContext.expectations) > 0 {
		mmScanAllContext.mock.t.Fatalf("Some expectations are already set for the DB.ScanAllContext method")
	}

	mmScanAllContext.mock.funcScanAllContext = f
	mmScanAllContext.mock.funcScanAllContextOrigin = minimock.CallerInfo(1)
	return mmScanAllContext.mock
}

// When sets expectation for the DB.ScanAllContext which will trigger the result defined by the following
// Then helper
func (mmScanAllContext *mDBMockScanAllContext) When(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) *DBMockScanAllContextExpectation {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	expectation := &DBMockScanAllContextExpectation{
		mock:               mmScanAllContext.mock,
		params:             &DBMockScanAllContextParams{ctx, deps, q, args},
		expectationOrigins: DBMockScanAllContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScanAllContext.expectations = append(mmScanAllContext.expectations, expectation)
	return expectation
}

// Then sets up DB.ScanAllContext return parameters for the expectation previously defined by the When method
func (e *DBMockScanAllContextExpectation) Then(err error) *DBMock {
	e.results = &DBMockScanAllContextResults{err}
	return e.mock
}

// Times sets number of times DB.ScanAllContext should be invoked
func (mmScanAllContext *mDBMockScanAllContext) Times(n uint64) *mDBMockScanAllContext {
	if n == 0 {
		mmScanAllContext.mock.t.Fatalf("Times of DBMock.ScanAllContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScanAllContext.expectedInvocations, n)
	mmScanAllContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScanAllContext
}

func (mmScanAllContext *mDBMockScanAllContext) invocationsDone() bool {
	if len(mmScanAllContext.expectations) == 0 && mmScanAllContext.defaultExpectation == nil && mmScanAllContext.mock.funcScanAllContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScanAllContext.mock.afterScanAllContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScanAllContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScanAllContext implements mm_database.DB
func (mmScanAllContext *DBMock) ScanAllContext(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanAllContext.beforeScanAllContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanAllContext.afterScanAllContextCounter, 1)

	mmScanAllContext.t.Helper()

	if mmScanAllContext.inspectFuncScanAllContext != nil {
		mmScanAllContext.inspectFuncScanAllContext(ctx, deps, q, args...)
	}

	mm_params := DBMockScanAllContextParams{ctx, deps, q, args}

	// Record call args
	mmScanAllContext.ScanAllContextMock.mutex.Lock()
	mmScanAllContext.ScanAllContextMock.callArgs = append(mmScanAllContext.ScanAllContextMock.callArgs, &mm_params)
	mmScanAllContext.ScanAllContextMock.mutex.Unlock()

	for _, e := range mmScanAllContext.ScanAllContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanAllContext.ScanAllContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanAllContext.ScanAllContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanAllContext.ScanAllContextMock.defaultExpectation.params
		mm_want_ptrs := mmScanAllContext.ScanAllContextMock.defaultExpectation.paramPtrs

		mm_got := DBMockScanAllContextParams{ctx, deps, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScanAllContext.t.Errorf("DBMock.ScanAllContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.deps != nil && !minimock.Equal(*mm_want_ptrs.deps, mm_got.deps) {
				mmScanAllContext.t.Errorf("DBMock.ScanAllContext got unexpected parameter deps, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.originDeps, *mm_want_ptrs.deps, mm_got.deps, minimock.Diff(*mm_want_ptrs.deps, mm_got.deps))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmScanAllContext.t.Errorf("DBMock.ScanAllContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmScanAllContext.t.Errorf("DBMock.ScanAllContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanAllContext.t.Errorf("DBMock.ScanAllContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanAllContext.ScanAllContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanAllContext.t.Fatal("No results are set for the DBMock.ScanAllContext")
		}
		return (*mm_results).err
	}
	if mmScanAllContext.funcScanAllContext != nil {
		return mmScanAllContext.funcScanAllContext(ctx, deps, q, args...)
	}
	mmScanAllContext.t.Fatalf("Unexpected call to DBMock.ScanAllContext. %v %v %v %v", ctx, deps, q, args)
	return
}

// ScanAllContextAfterCounter returns a count of finished DBMock.ScanAllContext invocations
func (mmScanAllContext *DBMock) ScanAllContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.afterScanAllContextCounter)
}

// ScanAllContextBeforeCounter returns a count of DBMock.ScanAllContext invocations
func (mmScanAllContext *DBMock) ScanAllContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.beforeScanAllContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.ScanAllContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanAllContext *mDBMockScanAllContext) Calls() []*DBMockScanAllContextParams {
	mmScanAllContext.mutex.RLock()

	argCopy := make([]*DBMockScanAllContextParams, len(mmScanAllContext.callArgs))
	copy(argCopy, mmScanAllContext.callArgs)

	mmScanAllContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanAllContextDone returns true if the count of the ScanAllContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockScanAllContextDone() bool {
	if m.ScanAllContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScanAllContextMock.invocationsDone()
}

// MinimockScanAllContextInspect logs each unmet expectation
func (m *DBMock) MinimockScanAllContextInspect() {
	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.ScanAllContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScanAllContextCounter := mm_atomic.LoadUint64(&m.afterScanAllContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllContextMock.defaultExpectation != nil && afterScanAllContextCounter < 1 {
		if m.ScanAllContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DBMock.ScanAllContext at\n%s", m.ScanAllContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DBMock.ScanAllContext at\n%s with params: %#v", m.ScanAllContextMock.defaultExpectation.expectationOrigins.origin, *m.ScanAllContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAllContext != nil && afterScanAllContextCounter < 1 {
		m.t.Errorf("Expected call to DBMock.ScanAllContext at\n%s", m.funcScanAllContextOrigin)
	}

	if !m.ScanAllContextMock.invocationsDone() && afterScanAllContextCounter > 0 {
		m.t.Errorf("Expected %d calls to DBMock.ScanAllContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScanAllContextMock.expectedInvocations), m.ScanAllContextMock.expectedInvocationsOrigin, afterScanAllContextCounter)
	}
}

type mDBMockScanOneContext struct {
	optional           bool
	mock               *DBMock
	defaultExpectation *DBMockScanOneContextExpectation
	expectations       []*DBMockScanOneContextExpectation

	callArgs []*DBMockScanOneContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DBMockScanOneContextExpectation specifies expectation struct of the DB.ScanOneContext
type DBMockScanOneContextExpectation struct {
	mock               *DBMock
	params             *DBMockScanOneContextParams
	paramPtrs          *DBMockScanOneContextParamPtrs
	expectationOrigins DBMockScanOneContextExpectationOrigins
	results            *DBMockScanOneContextResults
	returnOrigin       string
	Counter            uint64
}

// DBMockScanOneContextParams contains parameters of the DB.ScanOneContext
type DBMockScanOneContextParams struct {
	ctx  context.Context
	deps interface{}
	q    mm_database.Query
	args []interface{}
}

// DBMockScanOneContextParamPtrs contains pointers to parameters of the DB.ScanOneContext
type DBMockScanOneContextParamPtrs struct {
	ctx  *context.Context
	deps *interface{}
	q    *mm_database.Query
	args *[]interface{}
}

// DBMockScanOneContextResults contains results of the DB.ScanOneContext
type DBMockScanOneContextResults struct {
	err error
}

// DBMockScanOneContextOrigins contains origins of expectations of the DB.ScanOneContext
type DBMockScanOneContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originDeps string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScanOneContext *mDBMockScanOneContext) Optional() *mDBMockScanOneContext {
	mmScanOneContext.optional = true
	return mmScanOneContext
}

// Expect sets up expected params for DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) Expect(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) *mDBMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &DBMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.paramPtrs != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by ExpectParams functions")
	}

	mmScanOneContext.defaultExpectation.params = &DBMockScanOneContextParams{ctx, deps, q, args}
	mmScanOneContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScanOneContext.expectations {
		if minimock.Equal(e.params, mmScanOneContext.defaultExpectation.params) {
			mmScanOneContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanOneContext.defaultExpectation.params)
		}
	}

	return mmScanOneContext
}

// ExpectCtxParam1 sets up expected param ctx for DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) ExpectCtxParam1(ctx context.Context) *mDBMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &DBMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.params != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Expect")
	}

	if mmScanOneContext.defaultExpectation.paramPtrs == nil {
		mmScanOneContext.defaultExpectation.paramPtrs = &DBMockScanOneContextParamPtrs{}
	}
	mmScanOneContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmScanOneContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmScanOneContext
}

// ExpectDepsParam2 sets up expected param deps for DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) ExpectDepsParam2(deps interface{}) *mDBMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &DBMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.params != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Expect")
	}

	if mmScanOneContext.defaultExpectation.paramPtrs == nil {
		mmScanOneContext.defaultExpectation.paramPtrs = &DBMockScanOneContextParamPtrs{}
	}
	mmScanOneContext.defaultExpectation.paramPtrs.deps = &deps
	mmScanOneContext.defaultExpectation.expectationOrigins.originDeps = minimock.CallerInfo(1)

	return mmScanOneContext
}

// ExpectQParam3 sets up expected param q for DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) ExpectQParam3(q mm_database.Query) *mDBMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &DBMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.params != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Expect")
	}

	if mmScanOneContext.defaultExpectation.paramPtrs == nil {
		mmScanOneContext.defaultExpectation.paramPtrs = &DBMockScanOneContextParamPtrs{}
	}
	mmScanOneContext.defaultExpectation.paramPtrs.q = &q
	mmScanOneContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmScanOneContext
}

// ExpectArgsParam4 sets up expected param args for DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) ExpectArgsParam4(args ...interface{}) *mDBMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &DBMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.params != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Expect")
	}

	if mmScanOneContext.defaultExpectation.paramPtrs == nil {
		mmScanOneContext.defaultExpectation.paramPtrs = &DBMockScanOneContextParamPtrs{}
	}
	mmScanOneContext.defaultExpectation.paramPtrs.args = &args
	mmScanOneContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmScanOneContext
}

// Inspect accepts an inspector function that has same arguments as the DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) Inspect(f func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{})) *mDBMockScanOneContext {
	if mmScanOneContext.mock.inspectFuncScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("Inspect function is already set for DBMock.ScanOneContext")
	}

	mmScanOneContext.mock.inspectFuncScanOneContext = f

	return mmScanOneContext
}

// Return sets up results that will be returned by DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) Return(err error) *DBMock {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &DBMockScanOneContextExpectation{mock: mmScanOneContext.mock}
	}
	mmScanOneContext.defaultExpectation.results = &DBMockScanOneContextResults{err}
	mmScanOneContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScanOneContext.mock
}

// Set uses given function f to mock the DB.ScanOneContext method
func (mmScanOneContext *mDBMockScanOneContext) Set(f func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error)) *DBMock {
	if mmScanOneContext.defaultExpectation != nil {
		mmScanOneContext.mock.t.Fatalf("Default expectation is already set for the DB.ScanOneContext method")
	}

	if len(mmScanOneContext.expectations) > 0 {
		mmScanOneContext.mock.t.Fatalf("Some expectations are already set for the DB.ScanOneContext method")
	}

	mmScanOneContext.mock.funcScanOneContext = f
	mmScanOneContext.mock.funcScanOneContextOrigin = minimock.CallerInfo(1)
	return mmScanOneContext.mock
}

// When sets expectation for the DB.ScanOneContext which will trigger the result defined by the following
// Then helper
func (mmScanOneContext *mDBMockScanOneContext) When(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) *DBMockScanOneContextExpectation {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	expectation := &DBMockScanOneContextExpectation{
		mock:               mmScanOneContext.mock,
		params:             &DBMockScanOneContextParams{ctx, deps, q, args},
		expectationOrigins: DBMockScanOneContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScanOneContext.expectations = append(mmScanOneContext.expectations, expectation)
	return expectation
}

// Then sets up DB.ScanOneContext return parameters for the expectation previously defined by the When method
func (e *DBMockScanOneContextExpectation) Then(err error) *DBMock {
	e.results = &DBMockScanOneContextResults{err}
	return e.mock
}

// Times sets number of times DB.ScanOneContext should be invoked
func (mmScanOneContext *mDBMockScanOneContext) Times(n uint64) *mDBMockScanOneContext {
	if n == 0 {
		mmScanOneContext.mock.t.Fatalf("Times of DBMock.ScanOneContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScanOneContext.expectedInvocations, n)
	mmScanOneContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScanOneContext
}

func (mmScanOneContext *mDBMockScanOneContext) invocationsDone() bool {
	if len(mmScanOneContext.expectations) == 0 && mmScanOneContext.defaultExpectation == nil && mmScanOneContext.mock.funcScanOneContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScanOneContext.mock.afterScanOneContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScanOneContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScanOneContext implements mm_database.DB
func (mmScanOneContext *DBMock) ScanOneContext(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanOneContext.beforeScanOneContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanOneContext.afterScanOneContextCounter, 1)

	mmScanOneContext.t.Helper()

	if mmScanOneContext.inspectFuncScanOneContext != nil {
		mmScanOneContext.inspectFuncScanOneContext(ctx, deps, q, args...)
	}

	mm_params := DBMockScanOneContextParams{ctx, deps, q, args}

	// Record call args
	mmScanOneContext.ScanOneContextMock.mutex.Lock()
	mmScanOneContext.ScanOneContextMock.callArgs = append(mmScanOneContext.ScanOneContextMock.callArgs, &mm_params)
	mmScanOneContext.ScanOneContextMock.mutex.Unlock()

	for _, e := range mmScanOneContext.ScanOneContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanOneContext.ScanOneContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanOneContext.ScanOneContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanOneContext.ScanOneContextMock.defaultExpectation.params
		mm_want_ptrs := mmScanOneContext.ScanOneContextMock.defaultExpectation.paramPtrs

		mm_got := DBMockScanOneContextParams{ctx, deps, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScanOneContext.t.Errorf("DBMock.ScanOneContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.deps != nil && !minimock.Equal(*mm_want_ptrs.deps, mm_got.deps) {
				mmScanOneContext.t.Errorf("DBMock.ScanOneContext got unexpected parameter deps, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.originDeps, *mm_want_ptrs.deps, mm_got.deps, minimock.Diff(*mm_want_ptrs.deps, mm_got.deps))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmScanOneContext.t.Errorf("DBMock.ScanOneContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmScanOneContext.t.Errorf("DBMock.ScanOneContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanOneContext.t.Errorf("DBMock.ScanOneContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanOneContext.ScanOneContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanOneContext.t.Fatal("No results are set for the DBMock.ScanOneContext")
		}
		return (*mm_results).err
	}
	if mmScanOneContext.funcScanOneContext != nil {
		return mmScanOneContext.funcScanOneContext(ctx, deps, q, args...)
	}
	mmScanOneContext.t.Fatalf("Unexpected call to DBMock.ScanOneContext. %v %v %v %v", ctx, deps, q, args)
	return
}

// ScanOneContextAfterCounter returns a count of finished DBMock.ScanOneContext invocations
func (mmScanOneContext *DBMock) ScanOneContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.afterScanOneContextCounter)
}

// ScanOneContextBeforeCounter returns a count of DBMock.ScanOneContext invocations
func (mmScanOneContext *DBMock) ScanOneContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.beforeScanOneContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.ScanOneContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanOneContext *mDBMockScanOneContext) Calls() []*DBMockScanOneContextParams {
	mmScanOneContext.mutex.RLock()

	argCopy := make([]*DBMockScanOneContextParams, len(mmScanOneContext.callArgs))
	copy(argCopy, mmScanOneContext.callArgs)

	mmScanOneContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanOneContextDone returns true if the count of the ScanOneContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockScanOneContextDone() bool {
	if m.ScanOneContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScanOneContextMock.invocationsDone()
}

// MinimockScanOneContextInspect logs each unmet expectation
func (m *DBMock) MinimockScanOneContextInspect() {
	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.ScanOneContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScanOneContextCounter := mm_atomic.LoadUint64(&m.afterScanOneContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneContextMock.defaultExpectation != nil && afterScanOneContextCounter < 1 {
		if m.ScanOneContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DBMock.ScanOneContext at\n%s", m.ScanOneContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DBMock.ScanOneContext at\n%s with params: %#v", m.ScanOneContextMock.defaultExpectation.expectationOrigins.origin, *m.ScanOneContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOneContext != nil && afterScanOneContextCounter < 1 {
		m.t.Errorf("Expected call to DBMock.ScanOneContext at\n%s", m.funcScanOneContextOrigin)
	}

	if !m.ScanOneContextMock.invocationsDone() && afterScanOneContextCounter > 0 {
		m.t.Errorf("Expected %d calls to DBMock.ScanOneContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScanOneContextMock.expectedInvocations), m.ScanOneContextMock.expectedInvocationsOrigin, afterScanOneContextCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginTxInspect()

			m.MinimockCloseInspect()

			m.MinimockExecContextInspect()

			m.MinimockPingInspect()

			m.MinimockQueryContextInspect()

			m.MinimockQueryRowContextInspect()

			m.MinimockScanAllContextInspect()

			m.MinimockScanOneContextInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginTxDone() &&
		m.MinimockCloseDone() &&
		m.MinimockExecContextDone() &&
		m.MinimockPingDone() &&
		m.MinimockQueryContextDone() &&
		m.MinimockQueryRowContextDone() &&
		m.MinimockScanAllContextDone() &&
		m.MinimockScanOneContextDone()
}
