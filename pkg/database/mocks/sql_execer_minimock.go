// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i platform-pkg/pkg/database.SqlExecer -o sql_execer_minimock.go -n SqlExecerMock -p mocks

import (
	"context"
	mm_database "platform-pkg/pkg/database"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// SqlExecerMock implements mm_database.SqlExecer
type SqlExecerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExecContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)
	funcExecContextOrigin    string
	inspectFuncExecContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterExecContextCounter  uint64
	beforeExecContextCounter uint64
	ExecContextMock          mSqlExecerMockExecContext

	funcQueryContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error)
	funcQueryContextOrigin    string
	inspectFuncQueryContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterQueryContextCounter  uint64
	beforeQueryContextCounter uint64
	QueryContextMock          mSqlExecerMockQueryContext

	funcQueryRowContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row)
	funcQueryRowContextOrigin    string
	inspectFuncQueryRowContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterQueryRowContextCounter  uint64
	beforeQueryRowContextCounter uint64
	QueryRowContextMock          mSqlExecerMockQueryRowContext

	funcScanAllContext          func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error)
	funcScanAllContextOrigin    string
	inspectFuncScanAllContext   func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{})
	afterScanAllContextCounter  uint64
	beforeScanAllContextCounter uint64
	ScanAllContextMock          mSqlExecerMockScanAllContext

	funcScanOneContext          func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error)
	funcScanOneContextOrigin    string
	inspectFuncScanOneContext   func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{})
	afterScanOneContextCounter  uint64
	beforeScanOneContextCounter uint64
	ScanOneContextMock          mSqlExecerMockScanOneContext
}

// NewSqlExecerMock returns a mock for mm_database.SqlExecer
func NewSqlExecerMock(t minimock.Tester) *SqlExecerMock {
	m := &SqlExecerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExecContextMock = mSqlExecerMockExecContext{mock: m}
	m.ExecContextMock.callArgs = []*SqlExecerMockExecContextParams{}

	m.QueryContextMock = mSqlExecerMockQueryContext{mock: m}
	m.QueryContextMock.callArgs = []*SqlExecerMockQueryContextParams{}

	m.QueryRowContextMock = mSqlExecerMockQueryRowContext{mock: m}
	m.QueryRowContextMock.callArgs = []*SqlExecerMockQueryRowContextParams{}

	m.ScanAllContextMock = mSqlExecerMockScanAllContext{mock: m}
	m.ScanAllContextMock.callArgs = []*SqlExecerMockScanAllContextParams{}

	m.ScanOneContextMock = mSqlExecerMockScanOneContext{mock: m}
	m.ScanOneContextMock.callArgs = []*SqlExecerMockScanOneContextParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSqlExecerMockExecContext struct {
	optional           bool
	mock               *SqlExecerMock
	defaultExpectation *SqlExecerMockExecContextExpectation
	expectations       []*SqlExecerMockExecContextExpectation

	callArgs []*SqlExecerMockExecContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SqlExecerMockExecContextExpectation specifies expectation struct of the SqlExecer.ExecContext
type SqlExecerMockExecContextExpectation struct {
	mock               *SqlExecerMock
	params             *SqlExecerMockExecContextParams
	paramPtrs          *SqlExecerMockExecContextParamPtrs
	expectationOrigins SqlExecerMockExecContextExpectationOrigins
	results            *SqlExecerMockExecContextResults
	returnOrigin       string
	Counter            uint64
}

// SqlExecerMockExecContextParams contains parameters of the SqlExecer.ExecContext
type SqlExecerMockExecContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// SqlExecerMockExecContextParamPtrs contains pointers to parameters of the SqlExecer.ExecContext
type SqlExecerMockExecContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// SqlExecerMockExecContextResults contains results of the SqlExecer.ExecContext
type SqlExecerMockExecContextResults struct {
	c2  pgconn.CommandTag
	err error
}

// SqlExecerMockExecContextOrigins contains origins of expectations of the SqlExecer.ExecContext
type SqlExecerMockExecContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExecContext *mSqlExecerMockExecContext) Optional() *mSqlExecerMockExecContext {
	mmExecContext.optional = true
	return mmExecContext
}

// Expect sets up expected params for SqlExecer.ExecContext
func (mmExecContext *mSqlExecerMockExecContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mSqlExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &SqlExecerMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.paramPtrs != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by ExpectParams functions")
	}

	mmExecContext.defaultExpectation.params = &SqlExecerMockExecContextParams{ctx, q, args}
	mmExecContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExecContext.expectations {
		if minimock.Equal(e.params, mmExecContext.defaultExpectation.params) {
			mmExecContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecContext.defaultExpectation.params)
		}
	}

	return mmExecContext
}

// ExpectCtxParam1 sets up expected param ctx for SqlExecer.ExecContext
func (mmExecContext *mSqlExecerMockExecContext) ExpectCtxParam1(ctx context.Context) *mSqlExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &SqlExecerMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &SqlExecerMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmExecContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExecContext
}

// ExpectQParam2 sets up expected param q for SqlExecer.ExecContext
func (mmExecContext *mSqlExecerMockExecContext) ExpectQParam2(q mm_database.Query) *mSqlExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &SqlExecerMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &SqlExecerMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.q = &q
	mmExecContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmExecContext
}

// ExpectArgsParam3 sets up expected param args for SqlExecer.ExecContext
func (mmExecContext *mSqlExecerMockExecContext) ExpectArgsParam3(args ...interface{}) *mSqlExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &SqlExecerMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &SqlExecerMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.args = &args
	mmExecContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmExecContext
}

// Inspect accepts an inspector function that has same arguments as the SqlExecer.ExecContext
func (mmExecContext *mSqlExecerMockExecContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mSqlExecerMockExecContext {
	if mmExecContext.mock.inspectFuncExecContext != nil {
		mmExecContext.mock.t.Fatalf("Inspect function is already set for SqlExecerMock.ExecContext")
	}

	mmExecContext.mock.inspectFuncExecContext = f

	return mmExecContext
}

// Return sets up results that will be returned by SqlExecer.ExecContext
func (mmExecContext *mSqlExecerMockExecContext) Return(c2 pgconn.CommandTag, err error) *SqlExecerMock {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &SqlExecerMockExecContextExpectation{mock: mmExecContext.mock}
	}
	mmExecContext.defaultExpectation.results = &SqlExecerMockExecContextResults{c2, err}
	mmExecContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExecContext.mock
}

// Set uses given function f to mock the SqlExecer.ExecContext method
func (mmExecContext *mSqlExecerMockExecContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)) *SqlExecerMock {
	if mmExecContext.defaultExpectation != nil {
		mmExecContext.mock.t.Fatalf("Default expectation is already set for the SqlExecer.ExecContext method")
	}

	if len(mmExecContext.expectations) > 0 {
		mmExecContext.mock.t.Fatalf("Some expectations are already set for the SqlExecer.ExecContext method")
	}

	mmExecContext.mock.funcExecContext = f
	mmExecContext.mock.funcExecContextOrigin = minimock.CallerInfo(1)
	return mmExecContext.mock
}

// When sets expectation for the SqlExecer.ExecContext which will trigger the result defined by the following
// Then helper
func (mmExecContext *mSqlExecerMockExecContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *SqlExecerMockExecContextExpectation {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SqlExecerMock.ExecContext mock is already set by Set")
	}

	expectation := &SqlExecerMockExecContextExpectation{
		mock:               mmExecContext.mock,
		params:             &SqlExecerMockExecContextParams{ctx, q, args},
		expectationOrigins: SqlExecerMockExecContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExecContext.expectations = append(mmExecContext.expectations, expectation)
	return expectation
}

// Then sets up SqlExecer.ExecContext return parameters for the expectation previously defined by the When method
func (e *SqlExecerMockExecContextExpectation) Then(c2 pgconn.CommandTag, err error) *SqlExecerMock {
	e.results = &SqlExecerMockExecContextResults{c2, err}
	return e.mock
}

// Times sets number of times SqlExecer.ExecContext should be invoked
func (mmExecContext *mSqlExecerMockExecContext) Times(n uint64) *mSqlExecerMockExecContext {
	if n == 0 {
		mmExecContext.mock.t.Fatalf("Times of SqlExecerMock.ExecContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExecContext.expectedInvocations, n)
	mmExecContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExecContext
}

func (mmExecContext *mSqlExecerMockExecContext) invocationsDone() bool {
	if len(mmExecContext.expectations) == 0 && mmExecContext.defaultExpectation == nil && mmExecContext.mock.funcExecContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExecContext.mock.afterExecContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExecContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExecContext implements mm_database.SqlExecer
func (mmExecContext *SqlExecerMock) ExecContext(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExecContext.beforeExecContextCounter, 1)
	defer mm_atomic.AddUint64(&mmExecContext.afterExecContextCounter, 1)

	mmExecContext.t.Helper()

	if mmExecContext.inspectFuncExecContext != nil {
		mmExecContext.inspectFuncExecContext(ctx, q, args...)
	}

	mm_params := SqlExecerMockExecContextParams{ctx, q, args}

	// Record call args
	mmExecContext.ExecContextMock.mutex.Lock()
	mmExecContext.ExecContextMock.callArgs = append(mmExecContext.ExecContextMock.callArgs, &mm_params)
	mmExecContext.ExecContextMock.mutex.Unlock()

	for _, e := range mmExecContext.ExecContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmExecContext.ExecContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecContext.ExecContextMock.defaultExpectation.Counter, 1)
		mm_want := mmExecContext.ExecContextMock.defaultExpectation.params
		mm_want_ptrs := mmExecContext.ExecContextMock.defaultExpectation.paramPtrs

		mm_got := SqlExecerMockExecContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExecContext.t.Errorf("SqlExecerMock.ExecContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmExecContext.t.Errorf("SqlExecerMock.ExecContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmExecContext.t.Errorf("SqlExecerMock.ExecContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecContext.t.Errorf("SqlExecerMock.ExecContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecContext.ExecContextMock.defaultExpectation.results
		if mm_results == nil {
			mmExecContext.t.Fatal("No results are set for the SqlExecerMock.ExecContext")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmExecContext.funcExecContext != nil {
		return mmExecContext.funcExecContext(ctx, q, args...)
	}
	mmExecContext.t.Fatalf("Unexpected call to SqlExecerMock.ExecContext. %v %v %v", ctx, q, args)
	return
}

// ExecContextAfterCounter returns a count of finished SqlExecerMock.ExecContext invocations
func (mmExecContext *SqlExecerMock) ExecContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.afterExecContextCounter)
}

// ExecContextBeforeCounter returns a count of SqlExecerMock.ExecContext invocations
func (mmExecContext *SqlExecerMock) ExecContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.beforeExecContextCounter)
}

// Calls returns a list of arguments used in each call to SqlExecerMock.ExecContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecContext *mSqlExecerMockExecContext) Calls() []*SqlExecerMockExecContextParams {
	mmExecContext.mutex.RLock()

	argCopy := make([]*SqlExecerMockExecContextParams, len(mmExecContext.callArgs))
	copy(argCopy, mmExecContext.callArgs)

	mmExecContext.mutex.RUnlock()

	return argCopy
}

// MinimockExecContextDone returns true if the count of the ExecContext invocations corresponds
// the number of defined expectations
func (m *SqlExecerMock) MinimockExecContextDone() bool {
	if m.ExecContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecContextMock.invocationsDone()
}

// MinimockExecContextInspect logs each unmet expectation
func (m *SqlExecerMock) MinimockExecContextInspect() {
	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlExecerMock.ExecContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecContextCounter := mm_atomic.LoadUint64(&m.afterExecContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecContextMock.defaultExpectation != nil && afterExecContextCounter < 1 {
		if m.ExecContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SqlExecerMock.ExecContext at\n%s", m.ExecContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SqlExecerMock.ExecContext at\n%s with params: %#v", m.ExecContextMock.defaultExpectation.expectationOrigins.origin, *m.ExecContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecContext != nil && afterExecContextCounter < 1 {
		m.t.Errorf("Expected call to SqlExecerMock.ExecContext at\n%s", m.funcExecContextOrigin)
	}

	if !m.ExecContextMock.invocationsDone() && afterExecContextCounter > 0 {
		m.t.Errorf("Expected %d calls to SqlExecerMock.ExecContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecContextMock.expectedInvocations), m.ExecContextMock.expectedInvocationsOrigin, afterExecContextCounter)
	}
}

type mSqlExecerMockQueryContext struct {
	optional           bool
	mock               *SqlExecerMock
	defaultExpectation *SqlExecerMockQueryContextExpectation
	expectations       []*SqlExecerMockQueryContextExpectation

	callArgs []*SqlExecerMockQueryContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SqlExecerMockQueryContextExpectation specifies expectation struct of the SqlExecer.QueryContext
type SqlExecerMockQueryContextExpectation struct {
	mock               *SqlExecerMock
	params             *SqlExecerMockQueryContextParams
	paramPtrs          *SqlExecerMockQueryContextParamPtrs
	expectationOrigins SqlExecerMockQueryContextExpectationOrigins
	results            *SqlExecerMockQueryContextResults
	returnOrigin       string
	Counter            uint64
}

// SqlExecerMockQueryContextParams contains parameters of the SqlExecer.QueryContext
type SqlExecerMockQueryContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// SqlExecerMockQueryContextParamPtrs contains pointers to parameters of the SqlExecer.QueryContext
type SqlExecerMockQueryContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// SqlExecerMockQueryContextResults contains results of the SqlExecer.QueryContext
type SqlExecerMockQueryContextResults struct {
	r1  pgx.Rows
	err error
}

// SqlExecerMockQueryContextOrigins contains origins of expectations of the SqlExecer.QueryContext
type SqlExecerMockQueryContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryContext *mSqlExecerMockQueryContext) Optional() *mSqlExecerMockQueryContext {
	mmQueryContext.optional = true
	return mmQueryContext
}

// Expect sets up expected params for SqlExecer.QueryContext
func (mmQueryContext *mSqlExecerMockQueryContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mSqlExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &SqlExecerMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.paramPtrs != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by ExpectParams functions")
	}

	mmQueryContext.defaultExpectation.params = &SqlExecerMockQueryContextParams{ctx, q, args}
	mmQueryContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryContext.expectations {
		if minimock.Equal(e.params, mmQueryContext.defaultExpectation.params) {
			mmQueryContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryContext.defaultExpectation.params)
		}
	}

	return mmQueryContext
}

// ExpectCtxParam1 sets up expected param ctx for SqlExecer.QueryContext
func (mmQueryContext *mSqlExecerMockQueryContext) ExpectCtxParam1(ctx context.Context) *mSqlExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &SqlExecerMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &SqlExecerMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryContext
}

// ExpectQParam2 sets up expected param q for SqlExecer.QueryContext
func (mmQueryContext *mSqlExecerMockQueryContext) ExpectQParam2(q mm_database.Query) *mSqlExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &SqlExecerMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &SqlExecerMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.q = &q
	mmQueryContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmQueryContext
}

// ExpectArgsParam3 sets up expected param args for SqlExecer.QueryContext
func (mmQueryContext *mSqlExecerMockQueryContext) ExpectArgsParam3(args ...interface{}) *mSqlExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &SqlExecerMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &SqlExecerMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.args = &args
	mmQueryContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryContext
}

// Inspect accepts an inspector function that has same arguments as the SqlExecer.QueryContext
func (mmQueryContext *mSqlExecerMockQueryContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mSqlExecerMockQueryContext {
	if mmQueryContext.mock.inspectFuncQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("Inspect function is already set for SqlExecerMock.QueryContext")
	}

	mmQueryContext.mock.inspectFuncQueryContext = f

	return mmQueryContext
}

// Return sets up results that will be returned by SqlExecer.QueryContext
func (mmQueryContext *mSqlExecerMockQueryContext) Return(r1 pgx.Rows, err error) *SqlExecerMock {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &SqlExecerMockQueryContextExpectation{mock: mmQueryContext.mock}
	}
	mmQueryContext.defaultExpectation.results = &SqlExecerMockQueryContextResults{r1, err}
	mmQueryContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryContext.mock
}

// Set uses given function f to mock the SqlExecer.QueryContext method
func (mmQueryContext *mSqlExecerMockQueryContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error)) *SqlExecerMock {
	if mmQueryContext.defaultExpectation != nil {
		mmQueryContext.mock.t.Fatalf("Default expectation is already set for the SqlExecer.QueryContext method")
	}

	if len(mmQueryContext.expectations) > 0 {
		mmQueryContext.mock.t.Fatalf("Some expectations are already set for the SqlExecer.QueryContext method")
	}

	mmQueryContext.mock.funcQueryContext = f
	mmQueryContext.mock.funcQueryContextOrigin = minimock.CallerInfo(1)
	return mmQueryContext.mock
}

// When sets expectation for the SqlExecer.QueryContext which will trigger the result defined by the following
// Then helper
func (mmQueryContext *mSqlExecerMockQueryContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *SqlExecerMockQueryContextExpectation {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SqlExecerMock.QueryContext mock is already set by Set")
	}

	expectation := &SqlExecerMockQueryContextExpectation{
		mock:               mmQueryContext.mock,
		params:             &SqlExecerMockQueryContextParams{ctx, q, args},
		expectationOrigins: SqlExecerMockQueryContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryContext.expectations = append(mmQueryContext.expectations, expectation)
	return expectation
}

// Then sets up SqlExecer.QueryContext return parameters for the expectation previously defined by the When method
func (e *SqlExecerMockQueryContextExpectation) Then(r1 pgx.Rows, err error) *SqlExecerMock {
	e.results = &SqlExecerMockQueryContextResults{r1, err}
	return e.mock
}

// Times sets number of times SqlExecer.QueryContext should be invoked
func (mmQueryContext *mSqlExecerMockQueryContext) Times(n uint64) *mSqlExecerMockQueryContext {
	if n == 0 {
		mmQueryContext.mock.t.Fatalf("Times of SqlExecerMock.QueryContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryContext.expectedInvocations, n)
	mmQueryContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryContext
}

func (mmQueryContext *mSqlExecerMockQueryContext) invocationsDone() bool {
	if len(mmQueryContext.expectations) == 0 && mmQueryContext.defaultExpectation == nil && mmQueryContext.mock.funcQueryContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryContext.mock.afterQueryContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryContext implements mm_database.SqlExecer
func (mmQueryContext *SqlExecerMock) QueryContext(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQueryContext.beforeQueryContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryContext.afterQueryContextCounter, 1)

	mmQueryContext.t.Helper()

	if mmQueryContext.inspectFuncQueryContext != nil {
		mmQueryContext.inspectFuncQueryContext(ctx, q, args...)
	}

	mm_params := SqlExecerMockQueryContextParams{ctx, q, args}

	// Record call args
	mmQueryContext.QueryContextMock.mutex.Lock()
	mmQueryContext.QueryContextMock.callArgs = append(mmQueryContext.QueryContextMock.callArgs, &mm_params)
	mmQueryContext.QueryContextMock.mutex.Unlock()

	for _, e := range mmQueryContext.QueryContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQueryContext.QueryContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryContext.QueryContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryContext.QueryContextMock.defaultExpectation.params
		mm_want_ptrs := mmQueryContext.QueryContextMock.defaultExpectation.paramPtrs

		mm_got := SqlExecerMockQueryContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryContext.t.Errorf("SqlExecerMock.QueryContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmQueryContext.t.Errorf("SqlExecerMock.QueryContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryContext.t.Errorf("SqlExecerMock.QueryContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryContext.t.Errorf("SqlExecerMock.QueryContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryContext.QueryContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryContext.t.Fatal("No results are set for the SqlExecerMock.QueryContext")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQueryContext.funcQueryContext != nil {
		return mmQueryContext.funcQueryContext(ctx, q, args...)
	}
	mmQueryContext.t.Fatalf("Unexpected call to SqlExecerMock.QueryContext. %v %v %v", ctx, q, args)
	return
}

// QueryContextAfterCounter returns a count of finished SqlExecerMock.QueryContext invocations
func (mmQueryContext *SqlExecerMock) QueryContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.afterQueryContextCounter)
}

// QueryContextBeforeCounter returns a count of SqlExecerMock.QueryContext invocations
func (mmQueryContext *SqlExecerMock) QueryContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.beforeQueryContextCounter)
}

// Calls returns a list of arguments used in each call to SqlExecerMock.QueryContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryContext *mSqlExecerMockQueryContext) Calls() []*SqlExecerMockQueryContextParams {
	mmQueryContext.mutex.RLock()

	argCopy := make([]*SqlExecerMockQueryContextParams, len(mmQueryContext.callArgs))
	copy(argCopy, mmQueryContext.callArgs)

	mmQueryContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryContextDone returns true if the count of the QueryContext invocations corresponds
// the number of defined expectations
func (m *SqlExecerMock) MinimockQueryContextDone() bool {
	if m.QueryContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryContextMock.invocationsDone()
}

// MinimockQueryContextInspect logs each unmet expectation
func (m *SqlExecerMock) MinimockQueryContextInspect() {
	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlExecerMock.QueryContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryContextCounter := mm_atomic.LoadUint64(&m.afterQueryContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryContextMock.defaultExpectation != nil && afterQueryContextCounter < 1 {
		if m.QueryContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SqlExecerMock.QueryContext at\n%s", m.QueryContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SqlExecerMock.QueryContext at\n%s with params: %#v", m.QueryContextMock.defaultExpectation.expectationOrigins.origin, *m.QueryContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryContext != nil && afterQueryContextCounter < 1 {
		m.t.Errorf("Expected call to SqlExecerMock.QueryContext at\n%s", m.funcQueryContextOrigin)
	}

	if !m.QueryContextMock.invocationsDone() && afterQueryContextCounter > 0 {
		m.t.Errorf("Expected %d calls to SqlExecerMock.QueryContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryContextMock.expectedInvocations), m.QueryContextMock.expectedInvocationsOrigin, afterQueryContextCounter)
	}
}

type mSqlExecerMockQueryRowContext struct {
	optional           bool
	mock               *SqlExecerMock
	defaultExpectation *SqlExecerMockQueryRowContextExpectation
	expectations       []*SqlExecerMockQueryRowContextExpectation

	callArgs []*SqlExecerMockQueryRowContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SqlExecerMockQueryRowContextExpectation specifies expectation struct of the SqlExecer.QueryRowContext
type SqlExecerMockQueryRowContextExpectation struct {
	mock               *SqlExecerMock
	params             *SqlExecerMockQueryRowContextParams
	paramPtrs          *SqlExecerMockQueryRowContextParamPtrs
	expectationOrigins SqlExecerMockQueryRowContextExpectationOrigins
	results            *SqlExecerMockQueryRowContextResults
	returnOrigin       string
	Counter            uint64
}

// SqlExecerMockQueryRowContextParams contains parameters of the SqlExecer.QueryRowContext
type SqlExecerMockQueryRowContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// SqlExecerMockQueryRowContextParamPtrs contains pointers to parameters of the SqlExecer.QueryRowContext
type SqlExecerMockQueryRowContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// SqlExecerMockQueryRowContextResults contains results of the SqlExecer.QueryRowContext
type SqlExecerMockQueryRowContextResults struct {
	r1 pgx.Row
}

// SqlExecerMockQueryRowContextOrigins contains origins of expectations of the SqlExecer.QueryRowContext
type SqlExecerMockQueryRowContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) Optional() *mSqlExecerMockQueryRowContext {
	mmQueryRowContext.optional = true
	return mmQueryRowContext
}

// Expect sets up expected params for SqlExecer.QueryRowContext
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mSqlExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &SqlExecerMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by ExpectParams functions")
	}

	mmQueryRowContext.defaultExpectation.params = &SqlExecerMockQueryRowContextParams{ctx, q, args}
	mmQueryRowContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryRowContext.expectations {
		if minimock.Equal(e.params, mmQueryRowContext.defaultExpectation.params) {
			mmQueryRowContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRowContext.defaultExpectation.params)
		}
	}

	return mmQueryRowContext
}

// ExpectCtxParam1 sets up expected param ctx for SqlExecer.QueryRowContext
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) ExpectCtxParam1(ctx context.Context) *mSqlExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &SqlExecerMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &SqlExecerMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryRowContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// ExpectQParam2 sets up expected param q for SqlExecer.QueryRowContext
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) ExpectQParam2(q mm_database.Query) *mSqlExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &SqlExecerMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &SqlExecerMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.q = &q
	mmQueryRowContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// ExpectArgsParam3 sets up expected param args for SqlExecer.QueryRowContext
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) ExpectArgsParam3(args ...interface{}) *mSqlExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &SqlExecerMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &SqlExecerMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.args = &args
	mmQueryRowContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// Inspect accepts an inspector function that has same arguments as the SqlExecer.QueryRowContext
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mSqlExecerMockQueryRowContext {
	if mmQueryRowContext.mock.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("Inspect function is already set for SqlExecerMock.QueryRowContext")
	}

	mmQueryRowContext.mock.inspectFuncQueryRowContext = f

	return mmQueryRowContext
}

// Return sets up results that will be returned by SqlExecer.QueryRowContext
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) Return(r1 pgx.Row) *SqlExecerMock {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &SqlExecerMockQueryRowContextExpectation{mock: mmQueryRowContext.mock}
	}
	mmQueryRowContext.defaultExpectation.results = &SqlExecerMockQueryRowContextResults{r1}
	mmQueryRowContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext.mock
}

// Set uses given function f to mock the SqlExecer.QueryRowContext method
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row)) *SqlExecerMock {
	if mmQueryRowContext.defaultExpectation != nil {
		mmQueryRowContext.mock.t.Fatalf("Default expectation is already set for the SqlExecer.QueryRowContext method")
	}

	if len(mmQueryRowContext.expectations) > 0 {
		mmQueryRowContext.mock.t.Fatalf("Some expectations are already set for the SqlExecer.QueryRowContext method")
	}

	mmQueryRowContext.mock.funcQueryRowContext = f
	mmQueryRowContext.mock.funcQueryRowContextOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext.mock
}

// When sets expectation for the SqlExecer.QueryRowContext which will trigger the result defined by the following
// Then helper
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *SqlExecerMockQueryRowContextExpectation {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SqlExecerMock.QueryRowContext mock is already set by Set")
	}

	expectation := &SqlExecerMockQueryRowContextExpectation{
		mock:               mmQueryRowContext.mock,
		params:             &SqlExecerMockQueryRowContextParams{ctx, q, args},
		expectationOrigins: SqlExecerMockQueryRowContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryRowContext.expectations = append(mmQueryRowContext.expectations, expectation)
	return expectation
}

// Then sets up SqlExecer.QueryRowContext return parameters for the expectation previously defined by the When method
func (e *SqlExecerMockQueryRowContextExpectation) Then(r1 pgx.Row) *SqlExecerMock {
	e.results = &SqlExecerMockQueryRowContextResults{r1}
	return e.mock
}

// Times sets number of times SqlExecer.QueryRowContext should be invoked
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) Times(n uint64) *mSqlExecerMockQueryRowContext {
	if n == 0 {
		mmQueryRowContext.mock.t.Fatalf("Times of SqlExecerMock.QueryRowContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryRowContext.expectedInvocations, n)
	mmQueryRowContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext
}

func (mmQueryRowContext *mSqlExecerMockQueryRowContext) invocationsDone() bool {
	if len(mmQueryRowContext.expectations) == 0 && mmQueryRowContext.defaultExpectation == nil && mmQueryRowContext.mock.funcQueryRowContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryRowContext.mock.afterQueryRowContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryRowContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryRowContext implements mm_database.SqlExecer
func (mmQueryRowContext *SqlExecerMock) QueryRowContext(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRowContext.beforeQueryRowContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRowContext.afterQueryRowContextCounter, 1)

	mmQueryRowContext.t.Helper()

	if mmQueryRowContext.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.inspectFuncQueryRowContext(ctx, q, args...)
	}

	mm_params := SqlExecerMockQueryRowContextParams{ctx, q, args}

	// Record call args
	mmQueryRowContext.QueryRowContextMock.mutex.Lock()
	mmQueryRowContext.QueryRowContextMock.callArgs = append(mmQueryRowContext.QueryRowContextMock.callArgs, &mm_params)
	mmQueryRowContext.QueryRowContextMock.mutex.Unlock()

	for _, e := range mmQueryRowContext.QueryRowContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRowContext.QueryRowContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRowContext.QueryRowContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRowContext.QueryRowContextMock.defaultExpectation.params
		mm_want_ptrs := mmQueryRowContext.QueryRowContextMock.defaultExpectation.paramPtrs

		mm_got := SqlExecerMockQueryRowContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryRowContext.t.Errorf("SqlExecerMock.QueryRowContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmQueryRowContext.t.Errorf("SqlExecerMock.QueryRowContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryRowContext.t.Errorf("SqlExecerMock.QueryRowContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRowContext.t.Errorf("SqlExecerMock.QueryRowContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRowContext.QueryRowContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRowContext.t.Fatal("No results are set for the SqlExecerMock.QueryRowContext")
		}
		return (*mm_results).r1
	}
	if mmQueryRowContext.funcQueryRowContext != nil {
		return mmQueryRowContext.funcQueryRowContext(ctx, q, args...)
	}
	mmQueryRowContext.t.Fatalf("Unexpected call to SqlExecerMock.QueryRowContext. %v %v %v", ctx, q, args)
	return
}

// QueryRowContextAfterCounter returns a count of finished SqlExecerMock.QueryRowContext invocations
func (mmQueryRowContext *SqlExecerMock) QueryRowContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.afterQueryRowContextCounter)
}

// QueryRowContextBeforeCounter returns a count of SqlExecerMock.QueryRowContext invocations
func (mmQueryRowContext *SqlExecerMock) QueryRowContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.beforeQueryRowContextCounter)
}

// Calls returns a list of arguments used in each call to SqlExecerMock.QueryRowContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRowContext *mSqlExecerMockQueryRowContext) Calls() []*SqlExecerMockQueryRowContextParams {
	mmQueryRowContext.mutex.RLock()

	argCopy := make([]*SqlExecerMockQueryRowContextParams, len(mmQueryRowContext.callArgs))
	copy(argCopy, mmQueryRowContext.callArgs)

	mmQueryRowContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowContextDone returns true if the count of the QueryRowContext invocations corresponds
// the number of defined expectations
func (m *SqlExecerMock) MinimockQueryRowContextDone() bool {
	if m.QueryRowContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryRowContextMock.invocationsDone()
}

// MinimockQueryRowContextInspect logs each unmet expectation
func (m *SqlExecerMock) MinimockQueryRowContextInspect() {
	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlExecerMock.QueryRowContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryRowContextCounter := mm_atomic.LoadUint64(&m.afterQueryRowContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowContextMock.defaultExpectation != nil && afterQueryRowContextCounter < 1 {
		if m.QueryRowContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SqlExecerMock.QueryRowContext at\n%s", m.QueryRowContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SqlExecerMock.QueryRowContext at\n%s with params: %#v", m.QueryRowContextMock.defaultExpectation.expectationOrigins.origin, *m.QueryRowContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRowContext != nil && afterQueryRowContextCounter < 1 {
		m.t.Errorf("Expected call to SqlExecerMock.QueryRowContext at\n%s", m.funcQueryRowContextOrigin)
	}

	if !m.QueryRowContextMock.invocationsDone() && afterQueryRowContextCounter > 0 {
		m.t.Errorf("Expected %d calls to SqlExecerMock.QueryRowContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryRowContextMock.expectedInvocations), m.QueryRowContextMock.expectedInvocationsOrigin, afterQueryRowContextCounter)
	}
}

type mSqlExecerMockScanAllContext struct {
	optional           bool
	mock               *SqlExecerMock
	defaultExpectation *SqlExecerMockScanAllContextExpectation
	expectations       []*SqlExecerMockScanAllContextExpectation

	callArgs []*SqlExecerMockScanAllContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SqlExecerMockScanAllContextExpectation specifies expectation struct of the SqlExecer.ScanAllContext
type SqlExecerMockScanAllContextExpectation struct {
	mock               *SqlExecerMock
	params             *SqlExecerMockScanAllContextParams
	paramPtrs          *SqlExecerMockScanAllContextParamPtrs
	expectationOrigins SqlExecerMockScanAllContextExpectationOrigins
	results            *SqlExecerMockScanAllContextResults
	returnOrigin       string
	Counter            uint64
}

// SqlExecerMockScanAllContextParams contains parameters of the SqlExecer.ScanAllContext
type SqlExecerMockScanAllContextParams struct {
	ctx  context.Context
	deps interface{}
	q    mm_database.Query
	args []interface{}
}

// SqlExecerMockScanAllContextParamPtrs contains pointers to parameters of the SqlExecer.ScanAllContext
type SqlExecerMockScanAllContextParamPtrs struct {
	ctx  *context.Context
	deps *interface{}
	q    *mm_database.Query
	args *[]interface{}
}

// SqlExecerMockScanAllContextResults contains results of the SqlExecer.ScanAllContext
type SqlExecerMockScanAllContextResults struct {
	err error
}

// SqlExecerMockScanAllContextOrigins contains origins of expectations of the SqlExecer.ScanAllContext
type SqlExecerMockScanAllContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originDeps string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScanAllContext *mSqlExecerMockScanAllContext) Optional() *mSqlExecerMockScanAllContext {
	mmScanAllContext.optional = true
	return mmScanAllContext
}

// Expect sets up expected params for SqlExecer.ScanAllContext
func (mmScanAllContext *mSqlExecerMockScanAllContext) Expect(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) *mSqlExecerMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &SqlExecerMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.paramPtrs != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by ExpectParams functions")
	}

	mmScanAllContext.defaultExpectation.params = &SqlExecerMockScanAllContextParams{ctx, deps, q, args}
	mmScanAllContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScanAllContext.expectations {
		if minimock.Equal(e.params, mmScanAllContext.defaultExpectation.params) {
			mmScanAllContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanAllContext.defaultExpectation.params)
		}
	}

	return mmScanAllContext
}

// ExpectCtxParam1 sets up expected param ctx for SqlExecer.ScanAllContext
func (mmScanAllContext *mSqlExecerMockScanAllContext) ExpectCtxParam1(ctx context.Context) *mSqlExecerMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &SqlExecerMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.params != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Expect")
	}

	if mmScanAllContext.defaultExpectation.paramPtrs == nil {
		mmScanAllContext.defaultExpectation.paramPtrs = &SqlExecerMockScanAllContextParamPtrs{}
	}
	mmScanAllContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmScanAllContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmScanAllContext
}

// ExpectDepsParam2 sets up expected param deps for SqlExecer.ScanAllContext
func (mmScanAllContext *mSqlExecerMockScanAllContext) ExpectDepsParam2(deps interface{}) *mSqlExecerMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &SqlExecerMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.params != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Expect")
	}

	if mmScanAllContext.defaultExpectation.paramPtrs == nil {
		mmScanAllContext.defaultExpectation.paramPtrs = &SqlExecerMockScanAllContextParamPtrs{}
	}
	mmScanAllContext.defaultExpectation.paramPtrs.deps = &deps
	mmScanAllContext.defaultExpectation.expectationOrigins.originDeps = minimock.CallerInfo(1)

	return mmScanAllContext
}

// ExpectQParam3 sets up expected param q for SqlExecer.ScanAllContext
func (mmScanAllContext *mSqlExecerMockScanAllContext) ExpectQParam3(q mm_database.Query) *mSqlExecerMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &SqlExecerMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.params != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Expect")
	}

	if mmScanAllContext.defaultExpectation.paramPtrs == nil {
		mmScanAllContext.defaultExpectation.paramPtrs = &SqlExecerMockScanAllContextParamPtrs{}
	}
	mmScanAllContext.defaultExpectation.paramPtrs.q = &q
	mmScanAllContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmScanAllContext
}

// ExpectArgsParam4 sets up expected param args for SqlExecer.ScanAllContext
func (mmScanAllContext *mSqlExecerMockScanAllContext) ExpectArgsParam4(args ...interface{}) *mSqlExecerMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &SqlExecerMockScanAllContextExpectation{}
	}

	if mmScanAllContext.defaultExpectation.params != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Expect")
	}

	if mmScanAllContext.defaultExpectation.paramPtrs == nil {
		mmScanAllContext.defaultExpectation.paramPtrs = &SqlExecerMockScanAllContextParamPtrs{}
	}
	mmScanAllContext.defaultExpectation.paramPtrs.args = &args
	mmScanAllContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmScanAllContext
}

// Inspect accepts an inspector function that has same arguments as the SqlExecer.ScanAllContext
func (mmScanAllContext *mSqlExecerMockScanAllContext) Inspect(f func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{})) *mSqlExecerMockScanAllContext {
	if mmScanAllContext.mock.inspectFuncScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("Inspect function is already set for SqlExecerMock.ScanAllContext")
	}

	mmScanAllContext.mock.inspectFuncScanAllContext = f

	return mmScanAllContext
}

// Return sets up results that will be returned by SqlExecer.ScanAllContext
func (mmScanAllContext *mSqlExecerMockScanAllContext) Return(err error) *SqlExecerMock {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &SqlExecerMockScanAllContextExpectation{mock: mmScanAllContext.mock}
	}
	mmScanAllContext.defaultExpectation.results = &SqlExecerMockScanAllContextResults{err}
	mmScanAllContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScanAllContext.mock
}

// Set uses given function f to mock the SqlExecer.ScanAllContext method
func (mmScanAllContext *mSqlExecerMockScanAllContext) Set(f func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error)) *SqlExecerMock {
	if mmScanAllContext.defaultExpectation != nil {
		mmScanAllContext.mock.t.Fatalf("Default expectation is already set for the SqlExecer.ScanAllContext method")
	}

	if len(mmScanAllContext.expectations) > 0 {
		mmScanAllContext.mock.t.Fatalf("Some expectations are already set for the SqlExecer.ScanAllContext method")
	}

	mmScanAllContext.mock.funcScanAllContext = f
	mmScanAllContext.mock.funcScanAllContextOrigin = minimock.CallerInfo(1)
	return mmScanAllContext.mock
}

// When sets expectation for the SqlExecer.ScanAllContext which will trigger the result defined by the following
// Then helper
func (mmScanAllContext *mSqlExecerMockScanAllContext) When(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) *SqlExecerMockScanAllContextExpectation {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SqlExecerMock.ScanAllContext mock is already set by Set")
	}

	expectation := &SqlExecerMockScanAllContextExpectation{
		mock:               mmScanAllContext.mock,
		params:             &SqlExecerMockScanAllContextParams{ctx, deps, q, args},
		expectationOrigins: SqlExecerMockScanAllContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScanAllContext.expectations = append(mmScanAllContext.expectations, expectation)
	return expectation
}

// Then sets up SqlExecer.ScanAllContext return parameters for the expectation previously defined by the When method
func (e *SqlExecerMockScanAllContextExpectation) Then(err error) *SqlExecerMock {
	e.results = &SqlExecerMockScanAllContextResults{err}
	return e.mock
}

// Times sets number of times SqlExecer.ScanAllContext should be invoked
func (mmScanAllContext *mSqlExecerMockScanAllContext) Times(n uint64) *mSqlExecerMockScanAllContext {
	if n == 0 {
		mmScanAllContext.mock.t.Fatalf("Times of SqlExecerMock.ScanAllContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScanAllContext.expectedInvocations, n)
	mmScanAllContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScanAllContext
}

func (mmScanAllContext *mSqlExecerMockScanAllContext) invocationsDone() bool {
	if len(mmScanAllContext.expectations) == 0 && mmScanAllContext.defaultExpectation == nil && mmScanAllContext.mock.funcScanAllContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScanAllContext.mock.afterScanAllContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScanAllContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScanAllContext implements mm_database.SqlExecer
func (mmScanAllContext *SqlExecerMock) ScanAllContext(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanAllContext.beforeScanAllContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanAllContext.afterScanAllContextCounter, 1)

	mmScanAllContext.t.Helper()

	if mmScanAllContext.inspectFuncScanAllContext != nil {
		mmScanAllContext.inspectFuncScanAllContext(ctx, deps, q, args...)
	}

	mm_params := SqlExecerMockScanAllContextParams{ctx, deps, q, args}

	// Record call args
	mmScanAllContext.ScanAllContextMock.mutex.Lock()
	mmScanAllContext.ScanAllContextMock.callArgs = append(mmScanAllContext.ScanAllContextMock.callArgs, &mm_params)
	mmScanAllContext.ScanAllContextMock.mutex.Unlock()

	for _, e := range mmScanAllContext.ScanAllContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanAllContext.ScanAllContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanAllContext.ScanAllContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanAllContext.ScanAllContextMock.defaultExpectation.params
		mm_want_ptrs := mmScanAllContext.ScanAllContextMock.defaultExpectation.paramPtrs

		mm_got := SqlExecerMockScanAllContextParams{ctx, deps, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScanAllContext.t.Errorf("SqlExecerMock.ScanAllContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.deps != nil && !minimock.Equal(*mm_want_ptrs.deps, mm_got.deps) {
				mmScanAllContext.t.Errorf("SqlExecerMock.ScanAllContext got unexpected parameter deps, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.originDeps, *mm_want_ptrs.deps, mm_got.deps, minimock.Diff(*mm_want_ptrs.deps, mm_got.deps))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmScanAllContext.t.Errorf("SqlExecerMock.ScanAllContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmScanAllContext.t.Errorf("SqlExecerMock.ScanAllContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanAllContext.t.Errorf("SqlExecerMock.ScanAllContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScanAllContext.ScanAllContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanAllContext.ScanAllContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanAllContext.t.Fatal("No results are set for the SqlExecerMock.ScanAllContext")
		}
		return (*mm_results).err
	}
	if mmScanAllContext.funcScanAllContext != nil {
		return mmScanAllContext.funcScanAllContext(ctx, deps, q, args...)
	}
	mmScanAllContext.t.Fatalf("Unexpected call to SqlExecerMock.ScanAllContext. %v %v %v %v", ctx, deps, q, args)
	return
}

// ScanAllContextAfterCounter returns a count of finished SqlExecerMock.ScanAllContext invocations
func (mmScanAllContext *SqlExecerMock) ScanAllContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.afterScanAllContextCounter)
}

// ScanAllContextBeforeCounter returns a count of SqlExecerMock.ScanAllContext invocations
func (mmScanAllContext *SqlExecerMock) ScanAllContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.beforeScanAllContextCounter)
}

// Calls returns a list of arguments used in each call to SqlExecerMock.ScanAllContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanAllContext *mSqlExecerMockScanAllContext) Calls() []*SqlExecerMockScanAllContextParams {
	mmScanAllContext.mutex.RLock()

	argCopy := make([]*SqlExecerMockScanAllContextParams, len(mmScanAllContext.callArgs))
	copy(argCopy, mmScanAllContext.callArgs)

	mmScanAllContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanAllContextDone returns true if the count of the ScanAllContext invocations corresponds
// the number of defined expectations
func (m *SqlExecerMock) MinimockScanAllContextDone() bool {
	if m.ScanAllContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScanAllContextMock.invocationsDone()
}

// MinimockScanAllContextInspect logs each unmet expectation
func (m *SqlExecerMock) MinimockScanAllContextInspect() {
	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlExecerMock.ScanAllContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScanAllContextCounter := mm_atomic.LoadUint64(&m.afterScanAllContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllContextMock.defaultExpectation != nil && afterScanAllContextCounter < 1 {
		if m.ScanAllContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SqlExecerMock.ScanAllContext at\n%s", m.ScanAllContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SqlExecerMock.ScanAllContext at\n%s with params: %#v", m.ScanAllContextMock.defaultExpectation.expectationOrigins.origin, *m.ScanAllContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAllContext != nil && afterScanAllContextCounter < 1 {
		m.t.Errorf("Expected call to SqlExecerMock.ScanAllContext at\n%s", m.funcScanAllContextOrigin)
	}

	if !m.ScanAllContextMock.invocationsDone() && afterScanAllContextCounter > 0 {
		m.t.Errorf("Expected %d calls to SqlExecerMock.ScanAllContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScanAllContextMock.expectedInvocations), m.ScanAllContextMock.expectedInvocationsOrigin, afterScanAllContextCounter)
	}
}

type mSqlExecerMockScanOneContext struct {
	optional           bool
	mock               *SqlExecerMock
	defaultExpectation *SqlExecerMockScanOneContextExpectation
	expectations       []*SqlExecerMockScanOneContextExpectation

	callArgs []*SqlExecerMockScanOneContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SqlExecerMockScanOneContextExpectation specifies expectation struct of the SqlExecer.ScanOneContext
type SqlExecerMockScanOneContextExpectation struct {
	mock               *SqlExecerMock
	params             *SqlExecerMockScanOneContextParams
	paramPtrs          *SqlExecerMockScanOneContextParamPtrs
	expectationOrigins SqlExecerMockScanOneContextExpectationOrigins
	results            *SqlExecerMockScanOneContextResults
	returnOrigin       string
	Counter            uint64
}

// SqlExecerMockScanOneContextParams contains parameters of the SqlExecer.ScanOneContext
type SqlExecerMockScanOneContextParams struct {
	ctx  context.Context
	deps interface{}
	q    mm_database.Query
	args []interface{}
}

// SqlExecerMockScanOneContextParamPtrs contains pointers to parameters of the SqlExecer.ScanOneContext
type SqlExecerMockScanOneContextParamPtrs struct {
	ctx  *context.Context
	deps *interface{}
	q    *mm_database.Query
	args *[]interface{}
}

// SqlExecerMockScanOneContextResults contains results of the SqlExecer.ScanOneContext
type SqlExecerMockScanOneContextResults struct {
	err error
}

// SqlExecerMockScanOneContextOrigins contains origins of expectations of the SqlExecer.ScanOneContext
type SqlExecerMockScanOneContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originDeps string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScanOneContext *mSqlExecerMockScanOneContext) Optional() *mSqlExecerMockScanOneContext {
	mmScanOneContext.optional = true
	return mmScanOneContext
}

// Expect sets up expected params for SqlExecer.ScanOneContext
func (mmScanOneContext *mSqlExecerMockScanOneContext) Expect(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) *mSqlExecerMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &SqlExecerMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.paramPtrs != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by ExpectParams functions")
	}

	mmScanOneContext.defaultExpectation.params = &SqlExecerMockScanOneContextParams{ctx, deps, q, args}
	mmScanOneContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScanOneContext.expectations {
		if minimock.Equal(e.params, mmScanOneContext.defaultExpectation.params) {
			mmScanOneContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanOneContext.defaultExpectation.params)
		}
	}

	return mmScanOneContext
}

// ExpectCtxParam1 sets up expected param ctx for SqlExecer.ScanOneContext
func (mmScanOneContext *mSqlExecerMockScanOneContext) ExpectCtxParam1(ctx context.Context) *mSqlExecerMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &SqlExecerMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.params != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Expect")
	}

	if mmScanOneContext.defaultExpectation.paramPtrs == nil {
		mmScanOneContext.defaultExpectation.paramPtrs = &SqlExecerMockScanOneContextParamPtrs{}
	}
	mmScanOneContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmScanOneContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmScanOneContext
}

// ExpectDepsParam2 sets up expected param deps for SqlExecer.ScanOneContext
func (mmScanOneContext *mSqlExecerMockScanOneContext) ExpectDepsParam2(deps interface{}) *mSqlExecerMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &SqlExecerMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.params != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Expect")
	}

	if mmScanOneContext.defaultExpectation.paramPtrs == nil {
		mmScanOneContext.defaultExpectation.paramPtrs = &SqlExecerMockScanOneContextParamPtrs{}
	}
	mmScanOneContext.defaultExpectation.paramPtrs.deps = &deps
	mmScanOneContext.defaultExpectation.expectationOrigins.originDeps = minimock.CallerInfo(1)

	return mmScanOneContext
}

// ExpectQParam3 sets up expected param q for SqlExecer.ScanOneContext
func (mmScanOneContext *mSqlExecerMockScanOneContext) ExpectQParam3(q mm_database.Query) *mSqlExecerMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &SqlExecerMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.params != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Expect")
	}

	if mmScanOneContext.defaultExpectation.paramPtrs == nil {
		mmScanOneContext.defaultExpectation.paramPtrs = &SqlExecerMockScanOneContextParamPtrs{}
	}
	mmScanOneContext.defaultExpectation.paramPtrs.q = &q
	mmScanOneContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmScanOneContext
}

// ExpectArgsParam4 sets up expected param args for SqlExecer.ScanOneContext
func (mmScanOneContext *mSqlExecerMockScanOneContext) ExpectArgsParam4(args ...interface{}) *mSqlExecerMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &SqlExecerMockScanOneContextExpectation{}
	}

	if mmScanOneContext.defaultExpectation.params != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Expect")
	}

	if mmScanOneContext.defaultExpectation.paramPtrs == nil {
		mmScanOneContext.defaultExpectation.paramPtrs = &SqlExecerMockScanOneContextParamPtrs{}
	}
	mmScanOneContext.defaultExpectation.paramPtrs.args = &args
	mmScanOneContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmScanOneContext
}

// Inspect accepts an inspector function that has same arguments as the SqlExecer.ScanOneContext
func (mmScanOneContext *mSqlExecerMockScanOneContext) Inspect(f func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{})) *mSqlExecerMockScanOneContext {
	if mmScanOneContext.mock.inspectFuncScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("Inspect function is already set for SqlExecerMock.ScanOneContext")
	}

	mmScanOneContext.mock.inspectFuncScanOneContext = f

	return mmScanOneContext
}

// Return sets up results that will be returned by SqlExecer.ScanOneContext
func (mmScanOneContext *mSqlExecerMockScanOneContext) Return(err error) *SqlExecerMock {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &SqlExecerMockScanOneContextExpectation{mock: mmScanOneContext.mock}
	}
	mmScanOneContext.defaultExpectation.results = &SqlExecerMockScanOneContextResults{err}
	mmScanOneContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScanOneContext.mock
}

// Set uses given function f to mock the SqlExecer.ScanOneContext method
func (mmScanOneContext *mSqlExecerMockScanOneContext) Set(f func(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error)) *SqlExecerMock {
	if mmScanOneContext.defaultExpectation != nil {
		mmScanOneContext.mock.t.Fatalf("Default expectation is already set for the SqlExecer.ScanOneContext method")
	}

	if len(mmScanOneContext.expectations) > 0 {
		mmScanOneContext.mock.t.Fatalf("Some expectations are already set for the SqlExecer.ScanOneContext method")
	}

	mmScanOneContext.mock.funcScanOneContext = f
	mmScanOneContext.mock.funcScanOneContextOrigin = minimock.CallerInfo(1)
	return mmScanOneContext.mock
}

// When sets expectation for the SqlExecer.ScanOneContext which will trigger the result defined by the following
// Then helper
func (mmScanOneContext *mSqlExecerMockScanOneContext) When(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) *SqlExecerMockScanOneContextExpectation {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SqlExecerMock.ScanOneContext mock is already set by Set")
	}

	expectation := &SqlExecerMockScanOneContextExpectation{
		mock:               mmScanOneContext.mock,
		params:             &SqlExecerMockScanOneContextParams{ctx, deps, q, args},
		expectationOrigins: SqlExecerMockScanOneContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScanOneContext.expectations = append(mmScanOneContext.expectations, expectation)
	return expectation
}

// Then sets up SqlExecer.ScanOneContext return parameters for the expectation previously defined by the When method
func (e *SqlExecerMockScanOneContextExpectation) Then(err error) *SqlExecerMock {
	e.results = &SqlExecerMockScanOneContextResults{err}
	return e.mock
}

// Times sets number of times SqlExecer.ScanOneContext should be invoked
func (mmScanOneContext *mSqlExecerMockScanOneContext) Times(n uint64) *mSqlExecerMockScanOneContext {
	if n == 0 {
		mmScanOneContext.mock.t.Fatalf("Times of SqlExecerMock.ScanOneContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScanOneContext.expectedInvocations, n)
	mmScanOneContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScanOneContext
}

func (mmScanOneContext *mSqlExecerMockScanOneContext) invocationsDone() bool {
	if len(mmScanOneContext.expectations) == 0 && mmScanOneContext.defaultExpectation == nil && mmScanOneContext.mock.funcScanOneContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScanOneContext.mock.afterScanOneContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScanOneContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScanOneContext implements mm_database.SqlExecer
func (mmScanOneContext *SqlExecerMock) ScanOneContext(ctx context.Context, deps interface{}, q mm_database.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanOneContext.beforeScanOneContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanOneContext.afterScanOneContextCounter, 1)

	mmScanOneContext.t.Helper()

	if mmScanOneContext.inspectFuncScanOneContext != nil {
		mmScanOneContext.inspectFuncScanOneContext(ctx, deps, q, args...)
	}

	mm_params := SqlExecerMockScanOneContextParams{ctx, deps, q, args}

	// Record call args
	mmScanOneContext.ScanOneContextMock.mutex.Lock()
	mmScanOneContext.ScanOneContextMock.callArgs = append(mmScanOneContext.ScanOneContextMock.callArgs, &mm_params)
	mmScanOneContext.ScanOneContextMock.mutex.Unlock()

	for _, e := range mmScanOneContext.ScanOneContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanOneContext.ScanOneContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanOneContext.ScanOneContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanOneContext.ScanOneContextMock.defaultExpectation.params
		mm_want_ptrs := mmScanOneContext.ScanOneContextMock.defaultExpectation.paramPtrs

		mm_got := SqlExecerMockScanOneContextParams{ctx, deps, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScanOneContext.t.Errorf("SqlExecerMock.ScanOneContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.deps != nil && !minimock.Equal(*mm_want_ptrs.deps, mm_got.deps) {
				mmScanOneContext.t.Errorf("SqlExecerMock.ScanOneContext got unexpected parameter deps, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.originDeps, *mm_want_ptrs.deps, mm_got.deps, minimock.Diff(*mm_want_ptrs.deps, mm_got.deps))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmScanOneContext.t.Errorf("SqlExecerMock.ScanOneContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmScanOneContext.t.Errorf("SqlExecerMock.ScanOneContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanOneContext.t.Errorf("SqlExecerMock.ScanOneContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScanOneContext.ScanOneContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanOneContext.ScanOneContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanOneContext.t.Fatal("No results are set for the SqlExecerMock.ScanOneContext")
		}
		return (*mm_results).err
	}
	if mmScanOneContext.funcScanOneContext != nil {
		return mmScanOneContext.funcScanOneContext(ctx, deps, q, args...)
	}
	mmScanOneContext.t.Fatalf("Unexpected call to SqlExecerMock.ScanOneContext. %v %v %v %v", ctx, deps, q, args)
	return
}

// ScanOneContextAfterCounter returns a count of finished SqlExecerMock.ScanOneContext invocations
func (mmScanOneContext *SqlExecerMock) ScanOneContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.afterScanOneContextCounter)
}

// ScanOneContextBeforeCounter returns a count of SqlExecerMock.ScanOneContext invocations
func (mmScanOneContext *SqlExecerMock) ScanOneContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.beforeScanOneContextCounter)
}

// Calls returns a list of arguments used in each call to SqlExecerMock.ScanOneContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanOneContext *mSqlExecerMockScanOneContext) Calls() []*SqlExecerMockScanOneContextParams {
	mmScanOneContext.mutex.RLock()

	argCopy := make([]*SqlExecerMockScanOneContextParams, len(mmScanOneContext.callArgs))
	copy(argCopy, mmScanOneContext.callArgs)

	mmScanOneContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanOneContextDone returns true if the count of the ScanOneContext invocations corresponds
// the number of defined expectations
func (m *SqlExecerMock) MinimockScanOneContextDone() bool {
	if m.ScanOneContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScanOneContextMock.invocationsDone()
}

// MinimockScanOneContextInspect logs each unmet expectation
func (m *SqlExecerMock) MinimockScanOneContextInspect() {
	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlExecerMock.ScanOneContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScanOneContextCounter := mm_atomic.LoadUint64(&m.afterScanOneContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneContextMock.defaultExpectation != nil && afterScanOneContextCounter < 1 {
		if m.ScanOneContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SqlExecerMock.ScanOneContext at\n%s", m.ScanOneContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SqlExecerMock.ScanOneContext at\n%s with params: %#v", m.ScanOneContextMock.defaultExpectation.expectationOrigins.origin, *m.ScanOneContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOneContext != nil && afterScanOneContextCounter < 1 {
		m.t.Errorf("Expected call to SqlExecerMock.ScanOneContext at\n%s", m.funcScanOneContextOrigin)
	}

	if !m.ScanOneContextMock.invocationsDone() && afterScanOneContextCounter > 0 {
		m.t.Errorf("Expected %d calls to SqlExecerMock.ScanOneContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScanOneContextMock.expectedInvocations), m.ScanOneContextMock.expectedInvocationsOrigin, afterScanOneContextCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SqlExecerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExecContextInspect()

			m.MinimockQueryContextInspect()

			m.MinimockQueryRowContextInspect()

			m.MinimockScanAllContextInspect()

			m.MinimockScanOneContextInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SqlExecerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SqlExecerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExecContextDone() &&
		m.MinimockQueryContextDone() &&
		m.MinimockQueryRowContextDone() &&
		m.MinimockScanAllContextDone() &&
		m.MinimockScanOneContextDone()
}
