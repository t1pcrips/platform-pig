// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i platform-pkg/pkg/database.QueryExecer -o query_execer_minimock.go -n QueryExecerMock -p mocks

import (
	"context"
	mm_database "platform-pkg/pkg/database"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// QueryExecerMock implements mm_database.QueryExecer
type QueryExecerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExecContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)
	funcExecContextOrigin    string
	inspectFuncExecContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterExecContextCounter  uint64
	beforeExecContextCounter uint64
	ExecContextMock          mQueryExecerMockExecContext

	funcQueryContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error)
	funcQueryContextOrigin    string
	inspectFuncQueryContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterQueryContextCounter  uint64
	beforeQueryContextCounter uint64
	QueryContextMock          mQueryExecerMockQueryContext

	funcQueryRowContext          func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row)
	funcQueryRowContextOrigin    string
	inspectFuncQueryRowContext   func(ctx context.Context, q mm_database.Query, args ...interface{})
	afterQueryRowContextCounter  uint64
	beforeQueryRowContextCounter uint64
	QueryRowContextMock          mQueryExecerMockQueryRowContext
}

// NewQueryExecerMock returns a mock for mm_database.QueryExecer
func NewQueryExecerMock(t minimock.Tester) *QueryExecerMock {
	m := &QueryExecerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExecContextMock = mQueryExecerMockExecContext{mock: m}
	m.ExecContextMock.callArgs = []*QueryExecerMockExecContextParams{}

	m.QueryContextMock = mQueryExecerMockQueryContext{mock: m}
	m.QueryContextMock.callArgs = []*QueryExecerMockQueryContextParams{}

	m.QueryRowContextMock = mQueryExecerMockQueryRowContext{mock: m}
	m.QueryRowContextMock.callArgs = []*QueryExecerMockQueryRowContextParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mQueryExecerMockExecContext struct {
	optional           bool
	mock               *QueryExecerMock
	defaultExpectation *QueryExecerMockExecContextExpectation
	expectations       []*QueryExecerMockExecContextExpectation

	callArgs []*QueryExecerMockExecContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QueryExecerMockExecContextExpectation specifies expectation struct of the QueryExecer.ExecContext
type QueryExecerMockExecContextExpectation struct {
	mock               *QueryExecerMock
	params             *QueryExecerMockExecContextParams
	paramPtrs          *QueryExecerMockExecContextParamPtrs
	expectationOrigins QueryExecerMockExecContextExpectationOrigins
	results            *QueryExecerMockExecContextResults
	returnOrigin       string
	Counter            uint64
}

// QueryExecerMockExecContextParams contains parameters of the QueryExecer.ExecContext
type QueryExecerMockExecContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// QueryExecerMockExecContextParamPtrs contains pointers to parameters of the QueryExecer.ExecContext
type QueryExecerMockExecContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// QueryExecerMockExecContextResults contains results of the QueryExecer.ExecContext
type QueryExecerMockExecContextResults struct {
	c2  pgconn.CommandTag
	err error
}

// QueryExecerMockExecContextOrigins contains origins of expectations of the QueryExecer.ExecContext
type QueryExecerMockExecContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExecContext *mQueryExecerMockExecContext) Optional() *mQueryExecerMockExecContext {
	mmExecContext.optional = true
	return mmExecContext
}

// Expect sets up expected params for QueryExecer.ExecContext
func (mmExecContext *mQueryExecerMockExecContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mQueryExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &QueryExecerMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.paramPtrs != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by ExpectParams functions")
	}

	mmExecContext.defaultExpectation.params = &QueryExecerMockExecContextParams{ctx, q, args}
	mmExecContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExecContext.expectations {
		if minimock.Equal(e.params, mmExecContext.defaultExpectation.params) {
			mmExecContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecContext.defaultExpectation.params)
		}
	}

	return mmExecContext
}

// ExpectCtxParam1 sets up expected param ctx for QueryExecer.ExecContext
func (mmExecContext *mQueryExecerMockExecContext) ExpectCtxParam1(ctx context.Context) *mQueryExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &QueryExecerMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &QueryExecerMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmExecContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExecContext
}

// ExpectQParam2 sets up expected param q for QueryExecer.ExecContext
func (mmExecContext *mQueryExecerMockExecContext) ExpectQParam2(q mm_database.Query) *mQueryExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &QueryExecerMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &QueryExecerMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.q = &q
	mmExecContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmExecContext
}

// ExpectArgsParam3 sets up expected param args for QueryExecer.ExecContext
func (mmExecContext *mQueryExecerMockExecContext) ExpectArgsParam3(args ...interface{}) *mQueryExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &QueryExecerMockExecContextExpectation{}
	}

	if mmExecContext.defaultExpectation.params != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Expect")
	}

	if mmExecContext.defaultExpectation.paramPtrs == nil {
		mmExecContext.defaultExpectation.paramPtrs = &QueryExecerMockExecContextParamPtrs{}
	}
	mmExecContext.defaultExpectation.paramPtrs.args = &args
	mmExecContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmExecContext
}

// Inspect accepts an inspector function that has same arguments as the QueryExecer.ExecContext
func (mmExecContext *mQueryExecerMockExecContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mQueryExecerMockExecContext {
	if mmExecContext.mock.inspectFuncExecContext != nil {
		mmExecContext.mock.t.Fatalf("Inspect function is already set for QueryExecerMock.ExecContext")
	}

	mmExecContext.mock.inspectFuncExecContext = f

	return mmExecContext
}

// Return sets up results that will be returned by QueryExecer.ExecContext
func (mmExecContext *mQueryExecerMockExecContext) Return(c2 pgconn.CommandTag, err error) *QueryExecerMock {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &QueryExecerMockExecContextExpectation{mock: mmExecContext.mock}
	}
	mmExecContext.defaultExpectation.results = &QueryExecerMockExecContextResults{c2, err}
	mmExecContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExecContext.mock
}

// Set uses given function f to mock the QueryExecer.ExecContext method
func (mmExecContext *mQueryExecerMockExecContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)) *QueryExecerMock {
	if mmExecContext.defaultExpectation != nil {
		mmExecContext.mock.t.Fatalf("Default expectation is already set for the QueryExecer.ExecContext method")
	}

	if len(mmExecContext.expectations) > 0 {
		mmExecContext.mock.t.Fatalf("Some expectations are already set for the QueryExecer.ExecContext method")
	}

	mmExecContext.mock.funcExecContext = f
	mmExecContext.mock.funcExecContextOrigin = minimock.CallerInfo(1)
	return mmExecContext.mock
}

// When sets expectation for the QueryExecer.ExecContext which will trigger the result defined by the following
// Then helper
func (mmExecContext *mQueryExecerMockExecContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *QueryExecerMockExecContextExpectation {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("QueryExecerMock.ExecContext mock is already set by Set")
	}

	expectation := &QueryExecerMockExecContextExpectation{
		mock:               mmExecContext.mock,
		params:             &QueryExecerMockExecContextParams{ctx, q, args},
		expectationOrigins: QueryExecerMockExecContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExecContext.expectations = append(mmExecContext.expectations, expectation)
	return expectation
}

// Then sets up QueryExecer.ExecContext return parameters for the expectation previously defined by the When method
func (e *QueryExecerMockExecContextExpectation) Then(c2 pgconn.CommandTag, err error) *QueryExecerMock {
	e.results = &QueryExecerMockExecContextResults{c2, err}
	return e.mock
}

// Times sets number of times QueryExecer.ExecContext should be invoked
func (mmExecContext *mQueryExecerMockExecContext) Times(n uint64) *mQueryExecerMockExecContext {
	if n == 0 {
		mmExecContext.mock.t.Fatalf("Times of QueryExecerMock.ExecContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExecContext.expectedInvocations, n)
	mmExecContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExecContext
}

func (mmExecContext *mQueryExecerMockExecContext) invocationsDone() bool {
	if len(mmExecContext.expectations) == 0 && mmExecContext.defaultExpectation == nil && mmExecContext.mock.funcExecContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExecContext.mock.afterExecContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExecContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExecContext implements mm_database.QueryExecer
func (mmExecContext *QueryExecerMock) ExecContext(ctx context.Context, q mm_database.Query, args ...interface{}) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExecContext.beforeExecContextCounter, 1)
	defer mm_atomic.AddUint64(&mmExecContext.afterExecContextCounter, 1)

	mmExecContext.t.Helper()

	if mmExecContext.inspectFuncExecContext != nil {
		mmExecContext.inspectFuncExecContext(ctx, q, args...)
	}

	mm_params := QueryExecerMockExecContextParams{ctx, q, args}

	// Record call args
	mmExecContext.ExecContextMock.mutex.Lock()
	mmExecContext.ExecContextMock.callArgs = append(mmExecContext.ExecContextMock.callArgs, &mm_params)
	mmExecContext.ExecContextMock.mutex.Unlock()

	for _, e := range mmExecContext.ExecContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmExecContext.ExecContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecContext.ExecContextMock.defaultExpectation.Counter, 1)
		mm_want := mmExecContext.ExecContextMock.defaultExpectation.params
		mm_want_ptrs := mmExecContext.ExecContextMock.defaultExpectation.paramPtrs

		mm_got := QueryExecerMockExecContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExecContext.t.Errorf("QueryExecerMock.ExecContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmExecContext.t.Errorf("QueryExecerMock.ExecContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmExecContext.t.Errorf("QueryExecerMock.ExecContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecContext.t.Errorf("QueryExecerMock.ExecContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExecContext.ExecContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecContext.ExecContextMock.defaultExpectation.results
		if mm_results == nil {
			mmExecContext.t.Fatal("No results are set for the QueryExecerMock.ExecContext")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmExecContext.funcExecContext != nil {
		return mmExecContext.funcExecContext(ctx, q, args...)
	}
	mmExecContext.t.Fatalf("Unexpected call to QueryExecerMock.ExecContext. %v %v %v", ctx, q, args)
	return
}

// ExecContextAfterCounter returns a count of finished QueryExecerMock.ExecContext invocations
func (mmExecContext *QueryExecerMock) ExecContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.afterExecContextCounter)
}

// ExecContextBeforeCounter returns a count of QueryExecerMock.ExecContext invocations
func (mmExecContext *QueryExecerMock) ExecContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.beforeExecContextCounter)
}

// Calls returns a list of arguments used in each call to QueryExecerMock.ExecContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecContext *mQueryExecerMockExecContext) Calls() []*QueryExecerMockExecContextParams {
	mmExecContext.mutex.RLock()

	argCopy := make([]*QueryExecerMockExecContextParams, len(mmExecContext.callArgs))
	copy(argCopy, mmExecContext.callArgs)

	mmExecContext.mutex.RUnlock()

	return argCopy
}

// MinimockExecContextDone returns true if the count of the ExecContext invocations corresponds
// the number of defined expectations
func (m *QueryExecerMock) MinimockExecContextDone() bool {
	if m.ExecContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecContextMock.invocationsDone()
}

// MinimockExecContextInspect logs each unmet expectation
func (m *QueryExecerMock) MinimockExecContextInspect() {
	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QueryExecerMock.ExecContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecContextCounter := mm_atomic.LoadUint64(&m.afterExecContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecContextMock.defaultExpectation != nil && afterExecContextCounter < 1 {
		if m.ExecContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QueryExecerMock.ExecContext at\n%s", m.ExecContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QueryExecerMock.ExecContext at\n%s with params: %#v", m.ExecContextMock.defaultExpectation.expectationOrigins.origin, *m.ExecContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecContext != nil && afterExecContextCounter < 1 {
		m.t.Errorf("Expected call to QueryExecerMock.ExecContext at\n%s", m.funcExecContextOrigin)
	}

	if !m.ExecContextMock.invocationsDone() && afterExecContextCounter > 0 {
		m.t.Errorf("Expected %d calls to QueryExecerMock.ExecContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecContextMock.expectedInvocations), m.ExecContextMock.expectedInvocationsOrigin, afterExecContextCounter)
	}
}

type mQueryExecerMockQueryContext struct {
	optional           bool
	mock               *QueryExecerMock
	defaultExpectation *QueryExecerMockQueryContextExpectation
	expectations       []*QueryExecerMockQueryContextExpectation

	callArgs []*QueryExecerMockQueryContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QueryExecerMockQueryContextExpectation specifies expectation struct of the QueryExecer.QueryContext
type QueryExecerMockQueryContextExpectation struct {
	mock               *QueryExecerMock
	params             *QueryExecerMockQueryContextParams
	paramPtrs          *QueryExecerMockQueryContextParamPtrs
	expectationOrigins QueryExecerMockQueryContextExpectationOrigins
	results            *QueryExecerMockQueryContextResults
	returnOrigin       string
	Counter            uint64
}

// QueryExecerMockQueryContextParams contains parameters of the QueryExecer.QueryContext
type QueryExecerMockQueryContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// QueryExecerMockQueryContextParamPtrs contains pointers to parameters of the QueryExecer.QueryContext
type QueryExecerMockQueryContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// QueryExecerMockQueryContextResults contains results of the QueryExecer.QueryContext
type QueryExecerMockQueryContextResults struct {
	r1  pgx.Rows
	err error
}

// QueryExecerMockQueryContextOrigins contains origins of expectations of the QueryExecer.QueryContext
type QueryExecerMockQueryContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryContext *mQueryExecerMockQueryContext) Optional() *mQueryExecerMockQueryContext {
	mmQueryContext.optional = true
	return mmQueryContext
}

// Expect sets up expected params for QueryExecer.QueryContext
func (mmQueryContext *mQueryExecerMockQueryContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mQueryExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &QueryExecerMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.paramPtrs != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by ExpectParams functions")
	}

	mmQueryContext.defaultExpectation.params = &QueryExecerMockQueryContextParams{ctx, q, args}
	mmQueryContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryContext.expectations {
		if minimock.Equal(e.params, mmQueryContext.defaultExpectation.params) {
			mmQueryContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryContext.defaultExpectation.params)
		}
	}

	return mmQueryContext
}

// ExpectCtxParam1 sets up expected param ctx for QueryExecer.QueryContext
func (mmQueryContext *mQueryExecerMockQueryContext) ExpectCtxParam1(ctx context.Context) *mQueryExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &QueryExecerMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &QueryExecerMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryContext
}

// ExpectQParam2 sets up expected param q for QueryExecer.QueryContext
func (mmQueryContext *mQueryExecerMockQueryContext) ExpectQParam2(q mm_database.Query) *mQueryExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &QueryExecerMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &QueryExecerMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.q = &q
	mmQueryContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmQueryContext
}

// ExpectArgsParam3 sets up expected param args for QueryExecer.QueryContext
func (mmQueryContext *mQueryExecerMockQueryContext) ExpectArgsParam3(args ...interface{}) *mQueryExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &QueryExecerMockQueryContextExpectation{}
	}

	if mmQueryContext.defaultExpectation.params != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Expect")
	}

	if mmQueryContext.defaultExpectation.paramPtrs == nil {
		mmQueryContext.defaultExpectation.paramPtrs = &QueryExecerMockQueryContextParamPtrs{}
	}
	mmQueryContext.defaultExpectation.paramPtrs.args = &args
	mmQueryContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryContext
}

// Inspect accepts an inspector function that has same arguments as the QueryExecer.QueryContext
func (mmQueryContext *mQueryExecerMockQueryContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mQueryExecerMockQueryContext {
	if mmQueryContext.mock.inspectFuncQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("Inspect function is already set for QueryExecerMock.QueryContext")
	}

	mmQueryContext.mock.inspectFuncQueryContext = f

	return mmQueryContext
}

// Return sets up results that will be returned by QueryExecer.QueryContext
func (mmQueryContext *mQueryExecerMockQueryContext) Return(r1 pgx.Rows, err error) *QueryExecerMock {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &QueryExecerMockQueryContextExpectation{mock: mmQueryContext.mock}
	}
	mmQueryContext.defaultExpectation.results = &QueryExecerMockQueryContextResults{r1, err}
	mmQueryContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryContext.mock
}

// Set uses given function f to mock the QueryExecer.QueryContext method
func (mmQueryContext *mQueryExecerMockQueryContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error)) *QueryExecerMock {
	if mmQueryContext.defaultExpectation != nil {
		mmQueryContext.mock.t.Fatalf("Default expectation is already set for the QueryExecer.QueryContext method")
	}

	if len(mmQueryContext.expectations) > 0 {
		mmQueryContext.mock.t.Fatalf("Some expectations are already set for the QueryExecer.QueryContext method")
	}

	mmQueryContext.mock.funcQueryContext = f
	mmQueryContext.mock.funcQueryContextOrigin = minimock.CallerInfo(1)
	return mmQueryContext.mock
}

// When sets expectation for the QueryExecer.QueryContext which will trigger the result defined by the following
// Then helper
func (mmQueryContext *mQueryExecerMockQueryContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *QueryExecerMockQueryContextExpectation {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("QueryExecerMock.QueryContext mock is already set by Set")
	}

	expectation := &QueryExecerMockQueryContextExpectation{
		mock:               mmQueryContext.mock,
		params:             &QueryExecerMockQueryContextParams{ctx, q, args},
		expectationOrigins: QueryExecerMockQueryContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryContext.expectations = append(mmQueryContext.expectations, expectation)
	return expectation
}

// Then sets up QueryExecer.QueryContext return parameters for the expectation previously defined by the When method
func (e *QueryExecerMockQueryContextExpectation) Then(r1 pgx.Rows, err error) *QueryExecerMock {
	e.results = &QueryExecerMockQueryContextResults{r1, err}
	return e.mock
}

// Times sets number of times QueryExecer.QueryContext should be invoked
func (mmQueryContext *mQueryExecerMockQueryContext) Times(n uint64) *mQueryExecerMockQueryContext {
	if n == 0 {
		mmQueryContext.mock.t.Fatalf("Times of QueryExecerMock.QueryContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryContext.expectedInvocations, n)
	mmQueryContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryContext
}

func (mmQueryContext *mQueryExecerMockQueryContext) invocationsDone() bool {
	if len(mmQueryContext.expectations) == 0 && mmQueryContext.defaultExpectation == nil && mmQueryContext.mock.funcQueryContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryContext.mock.afterQueryContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryContext implements mm_database.QueryExecer
func (mmQueryContext *QueryExecerMock) QueryContext(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQueryContext.beforeQueryContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryContext.afterQueryContextCounter, 1)

	mmQueryContext.t.Helper()

	if mmQueryContext.inspectFuncQueryContext != nil {
		mmQueryContext.inspectFuncQueryContext(ctx, q, args...)
	}

	mm_params := QueryExecerMockQueryContextParams{ctx, q, args}

	// Record call args
	mmQueryContext.QueryContextMock.mutex.Lock()
	mmQueryContext.QueryContextMock.callArgs = append(mmQueryContext.QueryContextMock.callArgs, &mm_params)
	mmQueryContext.QueryContextMock.mutex.Unlock()

	for _, e := range mmQueryContext.QueryContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQueryContext.QueryContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryContext.QueryContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryContext.QueryContextMock.defaultExpectation.params
		mm_want_ptrs := mmQueryContext.QueryContextMock.defaultExpectation.paramPtrs

		mm_got := QueryExecerMockQueryContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryContext.t.Errorf("QueryExecerMock.QueryContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmQueryContext.t.Errorf("QueryExecerMock.QueryContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryContext.t.Errorf("QueryExecerMock.QueryContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryContext.t.Errorf("QueryExecerMock.QueryContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryContext.QueryContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryContext.QueryContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryContext.t.Fatal("No results are set for the QueryExecerMock.QueryContext")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQueryContext.funcQueryContext != nil {
		return mmQueryContext.funcQueryContext(ctx, q, args...)
	}
	mmQueryContext.t.Fatalf("Unexpected call to QueryExecerMock.QueryContext. %v %v %v", ctx, q, args)
	return
}

// QueryContextAfterCounter returns a count of finished QueryExecerMock.QueryContext invocations
func (mmQueryContext *QueryExecerMock) QueryContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.afterQueryContextCounter)
}

// QueryContextBeforeCounter returns a count of QueryExecerMock.QueryContext invocations
func (mmQueryContext *QueryExecerMock) QueryContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.beforeQueryContextCounter)
}

// Calls returns a list of arguments used in each call to QueryExecerMock.QueryContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryContext *mQueryExecerMockQueryContext) Calls() []*QueryExecerMockQueryContextParams {
	mmQueryContext.mutex.RLock()

	argCopy := make([]*QueryExecerMockQueryContextParams, len(mmQueryContext.callArgs))
	copy(argCopy, mmQueryContext.callArgs)

	mmQueryContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryContextDone returns true if the count of the QueryContext invocations corresponds
// the number of defined expectations
func (m *QueryExecerMock) MinimockQueryContextDone() bool {
	if m.QueryContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryContextMock.invocationsDone()
}

// MinimockQueryContextInspect logs each unmet expectation
func (m *QueryExecerMock) MinimockQueryContextInspect() {
	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QueryExecerMock.QueryContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryContextCounter := mm_atomic.LoadUint64(&m.afterQueryContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryContextMock.defaultExpectation != nil && afterQueryContextCounter < 1 {
		if m.QueryContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QueryExecerMock.QueryContext at\n%s", m.QueryContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QueryExecerMock.QueryContext at\n%s with params: %#v", m.QueryContextMock.defaultExpectation.expectationOrigins.origin, *m.QueryContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryContext != nil && afterQueryContextCounter < 1 {
		m.t.Errorf("Expected call to QueryExecerMock.QueryContext at\n%s", m.funcQueryContextOrigin)
	}

	if !m.QueryContextMock.invocationsDone() && afterQueryContextCounter > 0 {
		m.t.Errorf("Expected %d calls to QueryExecerMock.QueryContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryContextMock.expectedInvocations), m.QueryContextMock.expectedInvocationsOrigin, afterQueryContextCounter)
	}
}

type mQueryExecerMockQueryRowContext struct {
	optional           bool
	mock               *QueryExecerMock
	defaultExpectation *QueryExecerMockQueryRowContextExpectation
	expectations       []*QueryExecerMockQueryRowContextExpectation

	callArgs []*QueryExecerMockQueryRowContextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QueryExecerMockQueryRowContextExpectation specifies expectation struct of the QueryExecer.QueryRowContext
type QueryExecerMockQueryRowContextExpectation struct {
	mock               *QueryExecerMock
	params             *QueryExecerMockQueryRowContextParams
	paramPtrs          *QueryExecerMockQueryRowContextParamPtrs
	expectationOrigins QueryExecerMockQueryRowContextExpectationOrigins
	results            *QueryExecerMockQueryRowContextResults
	returnOrigin       string
	Counter            uint64
}

// QueryExecerMockQueryRowContextParams contains parameters of the QueryExecer.QueryRowContext
type QueryExecerMockQueryRowContextParams struct {
	ctx  context.Context
	q    mm_database.Query
	args []interface{}
}

// QueryExecerMockQueryRowContextParamPtrs contains pointers to parameters of the QueryExecer.QueryRowContext
type QueryExecerMockQueryRowContextParamPtrs struct {
	ctx  *context.Context
	q    *mm_database.Query
	args *[]interface{}
}

// QueryExecerMockQueryRowContextResults contains results of the QueryExecer.QueryRowContext
type QueryExecerMockQueryRowContextResults struct {
	r1 pgx.Row
}

// QueryExecerMockQueryRowContextOrigins contains origins of expectations of the QueryExecer.QueryRowContext
type QueryExecerMockQueryRowContextExpectationOrigins struct {
	origin     string
	originCtx  string
	originQ    string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) Optional() *mQueryExecerMockQueryRowContext {
	mmQueryRowContext.optional = true
	return mmQueryRowContext
}

// Expect sets up expected params for QueryExecer.QueryRowContext
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) Expect(ctx context.Context, q mm_database.Query, args ...interface{}) *mQueryExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &QueryExecerMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by ExpectParams functions")
	}

	mmQueryRowContext.defaultExpectation.params = &QueryExecerMockQueryRowContextParams{ctx, q, args}
	mmQueryRowContext.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryRowContext.expectations {
		if minimock.Equal(e.params, mmQueryRowContext.defaultExpectation.params) {
			mmQueryRowContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRowContext.defaultExpectation.params)
		}
	}

	return mmQueryRowContext
}

// ExpectCtxParam1 sets up expected param ctx for QueryExecer.QueryRowContext
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) ExpectCtxParam1(ctx context.Context) *mQueryExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &QueryExecerMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &QueryExecerMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryRowContext.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// ExpectQParam2 sets up expected param q for QueryExecer.QueryRowContext
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) ExpectQParam2(q mm_database.Query) *mQueryExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &QueryExecerMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &QueryExecerMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.q = &q
	mmQueryRowContext.defaultExpectation.expectationOrigins.originQ = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// ExpectArgsParam3 sets up expected param args for QueryExecer.QueryRowContext
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) ExpectArgsParam3(args ...interface{}) *mQueryExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &QueryExecerMockQueryRowContextExpectation{}
	}

	if mmQueryRowContext.defaultExpectation.params != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Expect")
	}

	if mmQueryRowContext.defaultExpectation.paramPtrs == nil {
		mmQueryRowContext.defaultExpectation.paramPtrs = &QueryExecerMockQueryRowContextParamPtrs{}
	}
	mmQueryRowContext.defaultExpectation.paramPtrs.args = &args
	mmQueryRowContext.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryRowContext
}

// Inspect accepts an inspector function that has same arguments as the QueryExecer.QueryRowContext
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) Inspect(f func(ctx context.Context, q mm_database.Query, args ...interface{})) *mQueryExecerMockQueryRowContext {
	if mmQueryRowContext.mock.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("Inspect function is already set for QueryExecerMock.QueryRowContext")
	}

	mmQueryRowContext.mock.inspectFuncQueryRowContext = f

	return mmQueryRowContext
}

// Return sets up results that will be returned by QueryExecer.QueryRowContext
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) Return(r1 pgx.Row) *QueryExecerMock {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &QueryExecerMockQueryRowContextExpectation{mock: mmQueryRowContext.mock}
	}
	mmQueryRowContext.defaultExpectation.results = &QueryExecerMockQueryRowContextResults{r1}
	mmQueryRowContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext.mock
}

// Set uses given function f to mock the QueryExecer.QueryRowContext method
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) Set(f func(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row)) *QueryExecerMock {
	if mmQueryRowContext.defaultExpectation != nil {
		mmQueryRowContext.mock.t.Fatalf("Default expectation is already set for the QueryExecer.QueryRowContext method")
	}

	if len(mmQueryRowContext.expectations) > 0 {
		mmQueryRowContext.mock.t.Fatalf("Some expectations are already set for the QueryExecer.QueryRowContext method")
	}

	mmQueryRowContext.mock.funcQueryRowContext = f
	mmQueryRowContext.mock.funcQueryRowContextOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext.mock
}

// When sets expectation for the QueryExecer.QueryRowContext which will trigger the result defined by the following
// Then helper
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) When(ctx context.Context, q mm_database.Query, args ...interface{}) *QueryExecerMockQueryRowContextExpectation {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("QueryExecerMock.QueryRowContext mock is already set by Set")
	}

	expectation := &QueryExecerMockQueryRowContextExpectation{
		mock:               mmQueryRowContext.mock,
		params:             &QueryExecerMockQueryRowContextParams{ctx, q, args},
		expectationOrigins: QueryExecerMockQueryRowContextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryRowContext.expectations = append(mmQueryRowContext.expectations, expectation)
	return expectation
}

// Then sets up QueryExecer.QueryRowContext return parameters for the expectation previously defined by the When method
func (e *QueryExecerMockQueryRowContextExpectation) Then(r1 pgx.Row) *QueryExecerMock {
	e.results = &QueryExecerMockQueryRowContextResults{r1}
	return e.mock
}

// Times sets number of times QueryExecer.QueryRowContext should be invoked
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) Times(n uint64) *mQueryExecerMockQueryRowContext {
	if n == 0 {
		mmQueryRowContext.mock.t.Fatalf("Times of QueryExecerMock.QueryRowContext mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryRowContext.expectedInvocations, n)
	mmQueryRowContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryRowContext
}

func (mmQueryRowContext *mQueryExecerMockQueryRowContext) invocationsDone() bool {
	if len(mmQueryRowContext.expectations) == 0 && mmQueryRowContext.defaultExpectation == nil && mmQueryRowContext.mock.funcQueryRowContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryRowContext.mock.afterQueryRowContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryRowContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryRowContext implements mm_database.QueryExecer
func (mmQueryRowContext *QueryExecerMock) QueryRowContext(ctx context.Context, q mm_database.Query, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRowContext.beforeQueryRowContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRowContext.afterQueryRowContextCounter, 1)

	mmQueryRowContext.t.Helper()

	if mmQueryRowContext.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.inspectFuncQueryRowContext(ctx, q, args...)
	}

	mm_params := QueryExecerMockQueryRowContextParams{ctx, q, args}

	// Record call args
	mmQueryRowContext.QueryRowContextMock.mutex.Lock()
	mmQueryRowContext.QueryRowContextMock.callArgs = append(mmQueryRowContext.QueryRowContextMock.callArgs, &mm_params)
	mmQueryRowContext.QueryRowContextMock.mutex.Unlock()

	for _, e := range mmQueryRowContext.QueryRowContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRowContext.QueryRowContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRowContext.QueryRowContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRowContext.QueryRowContextMock.defaultExpectation.params
		mm_want_ptrs := mmQueryRowContext.QueryRowContextMock.defaultExpectation.paramPtrs

		mm_got := QueryExecerMockQueryRowContextParams{ctx, q, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryRowContext.t.Errorf("QueryExecerMock.QueryRowContext got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q != nil && !minimock.Equal(*mm_want_ptrs.q, mm_got.q) {
				mmQueryRowContext.t.Errorf("QueryExecerMock.QueryRowContext got unexpected parameter q, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originQ, *mm_want_ptrs.q, mm_got.q, minimock.Diff(*mm_want_ptrs.q, mm_got.q))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryRowContext.t.Errorf("QueryExecerMock.QueryRowContext got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRowContext.t.Errorf("QueryExecerMock.QueryRowContext got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryRowContext.QueryRowContextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRowContext.QueryRowContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRowContext.t.Fatal("No results are set for the QueryExecerMock.QueryRowContext")
		}
		return (*mm_results).r1
	}
	if mmQueryRowContext.funcQueryRowContext != nil {
		return mmQueryRowContext.funcQueryRowContext(ctx, q, args...)
	}
	mmQueryRowContext.t.Fatalf("Unexpected call to QueryExecerMock.QueryRowContext. %v %v %v", ctx, q, args)
	return
}

// QueryRowContextAfterCounter returns a count of finished QueryExecerMock.QueryRowContext invocations
func (mmQueryRowContext *QueryExecerMock) QueryRowContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.afterQueryRowContextCounter)
}

// QueryRowContextBeforeCounter returns a count of QueryExecerMock.QueryRowContext invocations
func (mmQueryRowContext *QueryExecerMock) QueryRowContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.beforeQueryRowContextCounter)
}

// Calls returns a list of arguments used in each call to QueryExecerMock.QueryRowContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRowContext *mQueryExecerMockQueryRowContext) Calls() []*QueryExecerMockQueryRowContextParams {
	mmQueryRowContext.mutex.RLock()

	argCopy := make([]*QueryExecerMockQueryRowContextParams, len(mmQueryRowContext.callArgs))
	copy(argCopy, mmQueryRowContext.callArgs)

	mmQueryRowContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowContextDone returns true if the count of the QueryRowContext invocations corresponds
// the number of defined expectations
func (m *QueryExecerMock) MinimockQueryRowContextDone() bool {
	if m.QueryRowContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryRowContextMock.invocationsDone()
}

// MinimockQueryRowContextInspect logs each unmet expectation
func (m *QueryExecerMock) MinimockQueryRowContextInspect() {
	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QueryExecerMock.QueryRowContext at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryRowContextCounter := mm_atomic.LoadUint64(&m.afterQueryRowContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowContextMock.defaultExpectation != nil && afterQueryRowContextCounter < 1 {
		if m.QueryRowContextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QueryExecerMock.QueryRowContext at\n%s", m.QueryRowContextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QueryExecerMock.QueryRowContext at\n%s with params: %#v", m.QueryRowContextMock.defaultExpectation.expectationOrigins.origin, *m.QueryRowContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRowContext != nil && afterQueryRowContextCounter < 1 {
		m.t.Errorf("Expected call to QueryExecerMock.QueryRowContext at\n%s", m.funcQueryRowContextOrigin)
	}

	if !m.QueryRowContextMock.invocationsDone() && afterQueryRowContextCounter > 0 {
		m.t.Errorf("Expected %d calls to QueryExecerMock.QueryRowContext at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryRowContextMock.expectedInvocations), m.QueryRowContextMock.expectedInvocationsOrigin, afterQueryRowContextCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QueryExecerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExecContextInspect()

			m.MinimockQueryContextInspect()

			m.MinimockQueryRowContextInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QueryExecerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QueryExecerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExecContextDone() &&
		m.MinimockQueryContextDone() &&
		m.MinimockQueryRowContextDone()
}
